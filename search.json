[{"path":"https://novonordisk-opensource.github.io/postcard/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 postcard authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"generating-some-data-to-run-examples","dir":"Articles","previous_headings":"","what":"Generating some data to run examples","title":"Controlling behavior of model fitting functions","text":"vignette(\"postcard\"), simulate data using glm_data() function package.","code":"n <- 1000 b0 <- 1 b1 <- 3 b2 <- 2  dat_gaus <- glm_data(   Y ~ b0+b1*sin(W)^2+b2*A,   W = runif(n, min = -2, max = 2),   A = rbinom(n, 1, prob = 1/2) )  dat_gaus_hist <- glm_data(   Y ~ b0+b1*sin(W)^2,   W = runif(n, min = -2, max = 2) )  dat_pois <- glm_data(   Y ~ b0+b1*sin(W)^2+b2*A,   W = runif(n, min = -2, max = 2),   A = rbinom(n, 1, 1/2),   family = poisson(link = \"log\") )"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"controlling-verbosity","dir":"Articles","previous_headings":"","what":"Controlling verbosity","title":"Controlling behavior of model fitting functions","text":"See package level options documentation options(), giving information change package behavior options environmental variables. option verbose, controls amount information printed console. default, verbose = 2, meaning various information printed throughout algorithm. Change verbose = 1 little less information verbose = 0 information. showcase information printed different specifications verbosity. Verbosity suppressed rest vignette setting option postcard.verbose 0.","code":"# Default amount of printing ate <- rctglm(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   verbose = 2) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` ate_prog <- rctglm_with_prognosticscore(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   data_hist = dat_gaus_hist,   verbose = 2) #>  #> ‚îÄ‚îÄ Fitting prognostic model ‚îÄ‚îÄ #>  #> ‚Ñπ Created formula for fitting prognostic model as: Y ~ . #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> ‚Ä¢ mod_gbt #> i  No tuning parameters. `fit_resamples()` will be attempted #> i 1 of 3 resampling: mod_mars #> ‚úî 1 of 3 resampling: mod_mars (190ms) #> i  No tuning parameters. `fit_resamples()` will be attempted #> i 2 of 3 resampling: mod_lm #> ‚úî 2 of 3 resampling: mod_lm (97ms) #> i 3 of 3 tuning:     mod_gbt #> ‚úî 3 of 3 tuning:     mod_gbt (1.3s) #> ‚Ñπ Model with lowest RMSE: mod_mars #> ‚Ñπ Investigate trained learners and fitted model in `prognostic_info` list element #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` # At little less printing ate <- rctglm(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   verbose = 1) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` ate_prog <- rctglm_with_prognosticscore(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   data_hist = dat_gaus_hist,   verbose = 1) #>  #> ‚îÄ‚îÄ Fitting prognostic model ‚îÄ‚îÄ #>  #> ‚Ñπ Created formula for fitting prognostic model as: Y ~ . #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> ‚Ä¢ mod_gbt #> ‚Ñπ Model with lowest RMSE: mod_gbt #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` # No printing ate <- rctglm(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   verbose = 0) ate_prog <- rctglm_with_prognosticscore(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   data_hist = dat_gaus_hist,   verbose = 0)"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"specifying-the-estimand","dir":"Articles","previous_headings":"","what":"Specifying the estimand","title":"Controlling behavior of model fitting functions","text":"default estimand_fun rctglm() rctglm_with_prognosticscore() average treatment effect (ATE). However, ‚Äôs possible specify estimand giving function 2 named arguments, psi0 psi1. Note addition estimand_fun, functions also take arguments estimand_fun_deriv0 estimand_fun_deriv1, derivative respect psi0 psi1, respectively. default, NULL, means symbolic differentiation performed estimand_fun derive automatically. Note verbose > 0, information printed console results symbolic differentiation. run code verbose = 1 though otherwise muted vignette showcase .","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"built-in-estimands---average-treatment-effect-and-rate-ratio","dir":"Articles","previous_headings":"Specifying the estimand","what":"Built-in estimands - average treatment effect and rate ratio","title":"Controlling behavior of model fitting functions","text":"Built ATE rate ratio, can specified character strings. apparent documentation rctglm() rctglm_with_prognosticscore(), default estimand_fun \"ate\", similarly user can specify estimand_fun = \"rate_ratio\" use estimand function psi1 / psi0 seen :","code":"rate_ratio <- rctglm(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_pois,   family = \"poisson\",   estimand_fun = \"rate_ratio\",   verbose = 1) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1/psi0' with respect to 'psi0' as: '-(psi1/psi0^2)'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1/psi0' with respect to 'psi1' as: '1/psi0'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` rate_ratio$estimand_funs #> $f #> function (psi1, psi0)  #> psi1/psi0 #> <bytecode: 0x564baa3ce448> #> <environment: 0x564bb580e150> #>  #> $d0 #> function (psi1, psi0)  #> -(psi1/psi0^2) #> <environment: 0x564bb580e150> #>  #> $d1 #> function (psi1, psi0)  #> 1/psi0 #> <environment: 0x564bb580e150>"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"specifying-any-estimand","dir":"Articles","previous_headings":"Specifying the estimand","what":"Specifying any estimand","title":"Controlling behavior of model fitting functions","text":"example showing specification custom defined function arguments psi0 psi1.","code":"nonsense_estimand_fun <- function(psi1, psi0) {   psi1 / sqrt(psi0) * 2 - 1 }  nonsense_estimand <- rctglm(   formula = Y ~ A * W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_pois,   family = poisson(),   estimand_fun = nonsense_estimand_fun,   verbose = 1) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function '{     psi1/sqrt(psi0) * 2 - 1 }' with respect to 'psi0' as: '-(psi1/(psi0 * sqrt(psi0)))'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function '{     psi1/sqrt(psi0) * 2 - 1 }' with respect to 'psi1' as: '2/sqrt(psi0)'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` nonsense_estimand$estimand_funs #> $f #> function (psi1, psi0)  #> { #>     psi1/sqrt(psi0) * 2 - 1 #> } #>  #> $d0 #> function (psi1, psi0)  #> -(psi1/(psi0 * sqrt(psi0))) #>  #> $d1 #> function (psi1, psi0)  #> 2/sqrt(psi0)"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"variance-estimation-using-cross-validation","dir":"Articles","previous_headings":"","what":"Variance estimation using cross validation","title":"Controlling behavior of model fitting functions","text":"variance estimated variance influence function marginal effect. calculation function, counterfactual predictions made observations, using GLM predict outcome case exposure group 0 1, respectively. cv_variance argument rctglm() rctglm_with_prognosticscore() enables obtaining counterfactual predictions --sample (OOS) prediction using cross validation.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"prognostic-covariate-adjustment","dir":"Articles","previous_headings":"","what":"Prognostic covariate adjustment","title":"Controlling behavior of model fitting functions","text":"rctglm_with_prognosticscore() uses function fit_best_learner() fit prognostic model historical data, data_hist. Thereafter, model used predict prognostic scores observations data using scores covariate performing plug-estimation GLM using rctglm. behavior fit_best_learner() subsequently fitting prognostic model data_hist rctglm_with_prognosticscore() fit discrete super learner (discrete avoid overfitting) finding model lowest RMSE among list models. algorithm uses default 5 folds cross validation (cv_prog_folds) formula given prognostic model (prog_formula), function attempts model response name given formula using intercept main effect variables data_hist.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"specifying-learners","dir":"Articles","previous_headings":"Prognostic covariate adjustment","what":"Specifying learners","title":"Controlling behavior of model fitting functions","text":"fit_best_learner list default models use fitting discrete super learner, can seen section . However, ‚Äôs easy user specify list learners train discrete super learner. package utilises framework tidymodels, can seen list models can look like.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"default-learners","dir":"Articles","previous_headings":"Prognostic covariate adjustment > Specifying learners","what":"Default learners","title":"Controlling behavior of model fitting functions","text":"show code unexported default_learners function, creates list default learners used fit_best_learner() rctglm_with_prognosticscore(). body function thus represents valid way specifying learners argument.","code":"default_learners #> function ()  #> { #>     list(mars = list(model = parsnip::mars(mode = \"regression\",  #>         prod_degree = 3) %>% parsnip::set_engine(\"earth\")), lm = list(model = parsnip::linear_reg() %>%  #>         parsnip::set_engine(\"lm\")), gbt = list(model = parsnip::boost_tree(mode = \"regression\",  #>         trees = parsnip::tune(\"trees\"), tree_depth = parsnip::tune(\"tree_depth\"),  #>         learn_rate = 0.1) %>% parsnip::set_engine(\"xgboost\"),  #>         grid = data.frame(trees = seq(from = 25, to = 500, by = 25),  #>             tree_depth = 3))) #> } #> <bytecode: 0x564baa84f548> #> <environment: namespace:postcard>"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"creating-own-list-of-learners","dir":"Articles","previous_headings":"Prognostic covariate adjustment > Specifying learners","what":"Creating own list of learners","title":"Controlling behavior of model fitting functions","text":"listing models available tidymodels website, user can specify list models learners argument. example fitting prognostic model discrete super learner best RMSE among random forest linear support vector machines model.","code":"learners <- list(   rf = list(     model = parsnip::rand_forest(       mode = \"regression\",       trees = 500,       min_n = parsnip::tune(\"min_n\")     ) %>%        parsnip::set_engine(\"ranger\"),     grid = data.frame(       min_n = 1:10     )   ),   svm.linear = list(     model = parsnip::svm_linear(       mode = \"regression\",       cost = parsnip::tune(\"cost\"),       margin = parsnip::tune(\"margin\")) %>%        parsnip::set_engine(\"LiblineaR\"),     grid = data.frame(       cost = 1:5,       margin = seq(0.1, 0.5, 0.1)     )   ) )  model_own_learners <- rctglm_with_prognosticscore(   formula = Y ~ A * W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   data_hist = dat_gaus_hist,   learners = learners)"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/model-fit.html","id":"inspecting-the-prognostic-model","dir":"Articles","previous_headings":"Prognostic covariate adjustment","what":"Inspecting the prognostic model","title":"Controlling behavior of model fitting functions","text":"‚Äôs possible view information regarding fit prognostic model rctglm_prog class object rctglm_with_prognosticscore() returns looking list element prognostic_info. shorthand way using method prog(). Inside list element elements formula: formula used preproc fitting models fit_best_learner() model_fit: result fit_best_learner() learners: list learners used cv_folds: number folds used cross validation data: data given data_hist, prognostic model fitted upon Note change value data show first rows take much space printing vignette.","code":"prog_info <- prog(model_own_learners) prog_info$data <- head(prog_info$data) prog_info #> $formula #> Y ~ . #> <environment: 0x564bb56fc888> #>  #> $model_fit #> ‚ïê‚ïê Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Formula #> Model: rand_forest() #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Y ~ . #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Ranger result #>  #> Call: #>  ranger::ranger(x = maybe_data_frame(x), y = y, num.trees = ~500,      min.node.size = min_rows(~10L, x), num.threads = 1, verbose = FALSE,      seed = sample.int(10^5, 1))  #>  #> Type:                             Regression  #> Number of trees:                  500  #> Sample size:                      1000  #> Number of independent variables:  1  #> Mtry:                             1  #> Target node size:                 10  #> Variable importance mode:         none  #> Splitrule:                        variance  #> OOB prediction error (MSE):       1.383821  #> R squared (OOB):                  0.3918115  #>  #> $learners #> $learners$rf #> $learners$rf$model #> Random Forest Model Specification (regression) #>  #> Main Arguments: #>   trees = 500 #>   min_n = parsnip::tune(\"min_n\") #>  #> Computational engine: ranger  #>  #>  #> $learners$rf$grid #>    min_n #> 1      1 #> 2      2 #> 3      3 #> 4      4 #> 5      5 #> 6      6 #> 7      7 #> 8      8 #> 9      9 #> 10    10 #>  #>  #> $learners$svm.linear #> $learners$svm.linear$model #> Linear Support Vector Machine Model Specification (regression) #>  #> Main Arguments: #>   cost = parsnip::tune(\"cost\") #>   margin = parsnip::tune(\"margin\") #>  #> Computational engine: LiblineaR  #>  #>  #> $learners$svm.linear$grid #>   cost margin #> 1    1    0.1 #> 2    2    0.2 #> 3    3    0.3 #> 4    4    0.4 #> 5    5    0.5 #>  #>  #>  #> $cv_folds #> [1] 5 #>  #> $data #>           Y          W #> 1 4.0429142  1.8336410 #> 2 5.1553821  1.8259065 #> 3 4.5318651 -1.0377573 #> 4 4.1458895 -1.5460878 #> 5 2.2437462  0.3011256 #> 6 0.5276273  0.5514324"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"plug-in-estimation-of-marginal-effects-and-variance-estimation-using-influence-functions","dir":"Articles","previous_headings":"","what":"Plug-in estimation of marginal effects and variance estimation using influence functions","title":"Introduction to postcard","text":"use plug-estimation influence functions can help us obtain accurate estimates. Coupled prognostic covariate adjustment, can increase precision estimates obtain higher power sacrificing control type error rate. Introductory examples use rctglm() rctglm_with_prognosticscore() functions available . details, see vignette(\"model-fit\").","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"simulating-data-for-exploratory-analyses","dir":"Articles","previous_headings":"Plug-in estimation of marginal effects and variance estimation using influence functions","what":"Simulating data for exploratory analyses","title":"Introduction to postcard","text":"First, simulate data able enable showcasing functionalities. use glm_data() function package, user can specify expression alongside variables family response simulate response GLM linear predictor given expression provided.","code":"n <- 1000 b0 <- 1 b1 <- 3 b2 <- 2  # Simulate data with a non-linear effect dat_treat <- glm_data(   Y ~ b0+b1*sin(W)^2+b2*A,   W = runif(n, min = -2, max = 2),   A = rbinom(n, 1, prob = 1/2),   family = gaussian() # Default value )"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"fitting-rctglm-without-prognostic-covariate-adjustment","dir":"Articles","previous_headings":"Plug-in estimation of marginal effects and variance estimation using influence functions","what":"Fitting rctglm() without prognostic covariate adjustment","title":"Introduction to postcard","text":"rctglm() function estimates specified estimand using plug-estimation randomised clinical trials estimates variance using influence function marginal effect estimand. interface rctglm() similar stats::glm() function added mandatory specification randomisation variable data, usually (name ) treatment variable default, ratio 1‚Äôs data used default, function takes average treatment effect (ATE) estimand Thus, can estimate ATE simply writing : Note default, verbose = 2, meaning information algorithm printed console. However, suppress behavior. See vignette(\"model-fit\"). creates rctglm object prints structure rctglm object broken Value section documentation rctglm(). Methods available estimand (shorthand est) prints data.frame estimate estimand standard error. method coef also available extract coefficients underlying glm fit. See info documentation page rctglm_methods().","code":"ate <- rctglm(formula = Y ~ A * W,               exposure_indicator = A,               exposure_prob = 1/2,               data = dat_treat,               family = \"gaussian\") # Default value ate #>  #> Object of class rctglm  #>  #> Call:  rctglm(formula = Y ~ A * W, exposure_indicator = A, exposure_prob = 1/2,  #>     data = dat_treat, family = \"gaussian\") #>  #> Counterfactual control mean (psi_0=E[Y|X, A=0]) estimate: 2.776 #> Counterfactual control mean (psi_1=E[Y|X, A=1]) estimate: 4.867 #> Estimand function r: psi1 - psi0 #> Estimand (r(psi_1, psi_0)) estimate (SE): 2.091 (0.09209) est(ate) #>   Estimate Std. Error #> 1 2.091095 0.09209306"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"using-prognostic-covariate-adjustment","dir":"Articles","previous_headings":"Plug-in estimation of marginal effects and variance estimation using influence functions","what":"Using prognostic covariate adjustment","title":"Introduction to postcard","text":"rctglm_with_prognosticscore() function uses fit_best_learner() function fit prognostic model historical data uses prognostic model predict ùîº[Y|X,=0]\\begin{align} \\mathbb{E}[Y|X,=0] \\end{align} observations current data set. prognostic scores used covariate GLM running rctglm(). Allowing use complex non-linear models create prognostic score allows utilising information potentially many variables, ‚Äúcatching‚Äù non-linear relationships using information GLM model using single covariate adjustment. simulate historical data showcase use function well: call rctglm_with_prognosticscore() rctglm() added specification (Historical) data fit prognostic model using fit_best_learner() Default uses covariates data. (Optionally) number folds cross validation list learners fitting best learner Thus, simple call estimates average treatment effect, adjusting prognostic score, seen : Quick results fit can seen printing object: ‚Äôs evident case non-linear relationship covariate observe response, adjusting prognostic score reduces standard error estimand approximation quite bit.","code":"dat_notreat <- glm_data(   Y ~ b0+b1*sin(W)^2,   W = runif(n, min = -2, max = 2),   family = gaussian # Default value ) ate_prog <- rctglm_with_prognosticscore(   formula = Y ~ A * W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_treat,   family = gaussian(link = \"identity\"), # Default value   data_hist = dat_notreat) ate_prog #>  #> Object of class rctglm_prog  #>  #> Call:  rctglm_with_prognosticscore(formula = Y ~ A * W, exposure_indicator = A,  #>     exposure_prob = 1/2, data = dat_treat, family = gaussian(link = \"identity\"),  #>     data_hist = dat_notreat) #>  #> Counterfactual control mean (psi_0=E[Y|X, A=0]) estimate: 2.827 #> Counterfactual control mean (psi_1=E[Y|X, A=1]) estimate: 4.821 #> Estimand function r: psi1 - psi0 #> Estimand (r(psi_1, psi_0)) estimate (SE): 1.994 (0.06405)"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"investigating-the-prognostic-model","dir":"Articles","previous_headings":"Plug-in estimation of marginal effects and variance estimation using influence functions > Using prognostic covariate adjustment","what":"Investigating the prognostic model","title":"Introduction to postcard","text":"Information prognostic model available list element prognostic_info, method prog() can used extract. breakdown list includes, see Value section rctglm_with_prognosticscore() documentation.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"power-approximation","dir":"Articles","previous_headings":"","what":"Power approximation","title":"Introduction to postcard","text":"cases seeking conduct new studies, sample size/power analyses vital successful planning studies. , present implementations package take advantage power approximation formulas perform analyses. See detailed walkthrough use case vignette(\"prospective-power\").","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"for-marginal-effects","dir":"Articles","previous_headings":"Power approximation","what":"For marginal effects","title":"Introduction to postcard","text":"method proposed Powering RCTs marginal effects GLMs using prognostic score adjustment H√∏jbjerre-Frandsen et. al (2025), can used estimate power estimating marginal effect, implemented function power_marginaleffect(). According conservative approach article, wanting conduct power analyses figure many participants needed upcoming trial, planning use prognostic covariate adjustment, predictions obtained discrete super learner identical one planned use generating prognostic scores adjusting analysis estimating marginal effect. showcase simple use glm(), fx. fit_best_learner() used fit discrete super learner prediction model. also add steps get --sample (OOS) predictions (see examples).","code":"pred_mod <- glm(Y ~ W + A, data = dat_treat) preds <- predict(pred_mod, dat_treat)  power_marginaleffect(   response = dat_treat$Y,   predictions = preds,   target_effect = 0.4,   exposure_prob = 1/2 ) #> [1] 0.9056303"},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"estimating-the-assumed-variance","dir":"Articles","previous_headings":"Power approximation > Specific to linear models","what":"Estimating the assumed variance","title":"Introduction to postcard","text":"Finding assumed variance use power analysis ANCOVA model can done using variance_ancova function, estimates term œÉ2(1‚àíR2)\\sigma^2(1-R^2) given formula data.","code":"vanc <- variance_ancova(Y ~ A + W, data = dat_treat) vanc #> [1] 2.120278"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/postcard.html","id":"finding-the-power-or-sample-size","dir":"Articles","previous_headings":"Power approximation > Specific to linear models","what":"Finding the power (or sample size)","title":"Introduction to postcard","text":"Functions power_gs() power_nc() exist, estimate power given sample size n using approximation formulas. functions results two different approximation formulas behave exactly except mandatory specification df argument power_nc function, gives degrees freedom t-distribution used. Details formulas available documentation Guenther-Schouten approximation, formula directly gives us sample size function power, getting required sample size function power available function samplesize_gs().","code":"power_gs(variance = vanc, n = 100, ate = 0.8) #> [1] 0.7765394 power_nc(variance = vanc, n = 100, df = 97, ate = 0.8) #> [1] 0.7763057 samplesize_gs(variance = vanc, ate = 0.8, power = 0.9) #> [1] 141.1623"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/prospective-power.html","id":"estimating-the-power-for-marginal-effects","dir":"Articles","previous_headings":"","what":"Estimating the power for marginal effects","title":"Prospective Power Estimation","text":"method proposed Powering RCTs marginal effects GLMs using prognostic score adjustment H√∏jbjerre-Frandsen et. al (2025), can used estimate power estimating marginal effect, implemented function power_marginaleffect(). introductory example available vignette(\"postcard\"), describe specify arguments change default behavior function align assumptions power estimation.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/prospective-power.html","id":"simulating-some-data","dir":"Articles","previous_headings":"Estimating the power for marginal effects","what":"Simulating some data","title":"Prospective Power Estimation","text":"generate count data showcase flexibility power_marginaleffect() assume linear model.","code":"n_train <- 2000 n_test <- 200 b1 <- 1.2 b2 <- 2.3 b3 <- 1 b4 <- 1.8  train_pois <- dplyr::mutate(   glm_data(     Y ~ b1*abs(sin(X1))-b2*X2+b3*X3-b4*X2*X3,     X1 = runif(n_train, min = -2, max = 2),     X2 = rnorm(n_train, mean = 2, sd = 2),     X3 = rgamma(n_train, shape = 1),     family = gaussian()   ),   Y = round(abs(Y)) ) test_pois <- dplyr::mutate(   glm_data(     Y ~ b1*abs(sin(X1))-b2*X2+b3*X3-b4*X2*X3,     X1 = runif(n_test, min = -2, max = 2),     X2 = rnorm(n_test, mean = 2, sd = 2),     X3 = rgamma(n_test, shape = 1),     family = gaussian()   ),   Y = round(abs(Y)) )"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/prospective-power.html","id":"controlling-assumptions","dir":"Articles","previous_headings":"Estimating the power for marginal effects","what":"Controlling assumptions","title":"Prospective Power Estimation","text":"default, variance group 0 estimated sample variance response, variance group 1 assumed estimated variance group 0. Use argument var1 change variance estimate group 1, either function modifies estimate obtained group 0 numeric. true MSE, kappa1_squared default taken MSE group 0 unless function numeric specified. example showcasing specification var1 kappa1_squared according prior beliefs.","code":"lrnr <- fit_best_learner(list(mod = Y ~ X1 + X2 + X3), data = train_pois) preds <- dplyr::pull(predict(lrnr, new_data = test_pois))  power_marginaleffect(   response = test_pois$Y,   predictions = preds,   var1 = function(var0) 1.2 * var0,   kappa1_squared = 2,   estimand_fun = \"rate_ratio\",   target_effect = 1.3,   exposure_prob = 1/2 ) #> [1] 0.8377895"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/prospective-power.html","id":"for-linear-models","dir":"Articles","previous_headings":"","what":"For linear models","title":"Prospective Power Estimation","text":"functions described help page power_linear() provide utilities prospective power calculations using linear models. conduct sample size calculations constructing power curves using standard ANCOVA method described (Guenther WC. Sample Size Formulas Normal Theory T Tests. American Statistician. 1981;35(4):243‚Äì244) (Schouten HJA. Sample size formula continuous outcome unequal group sizes unequal variances. Statistics Medicine. 1999;18(1):87‚Äì91). compare resulting power ANCOVA models leverage prognostic covariate adjustment ones don‚Äôt. usual cases wanting conduct sample size/power analyses prospectively, data new exposure available time analysis. can use historical data comparator group estimate variance adjust according beliefs might data novel group.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/articles/prospective-power.html","id":"simulating-data","dir":"Articles","previous_headings":"For linear models","what":"Simulating data","title":"Prospective Power Estimation","text":"described , data available time prospective power analysis. showcase common use case, simulate historical data, use estimate variance response adjusted coefficient determination function variance_ancova(). compare power curves ‚Äústandard‚Äù ANCOVA model one using prognostic covariate adjustment, simulate historical data, can fit prognostic model training data use resulting model predict prognostic scores test data.","code":"# Generate some data b0 <- 1 b1 <- 1.6 b2 <- 1.4 b3 <- 2 b4 <- 0.8  train <- glm_data(   Y ~ b0+b1*abs(sin(X1))+b2*X2+b3*X3+b4*X2*X3,   X1 = runif(n_train, min = -2, max = 2),   X2 = rnorm(n_train, mean = 2, sd = 2),   X3 = rbinom(n_train, 1, 0.5) )  test <- glm_data(   Y ~ b0+b1*abs(sin(X1))+b2*X2+b3*X3+b4*X2*X3,   X1 = runif(n_test, min = -2, max = 2),   X2 = rnorm(n_test, mean = 2, sd = 2),   X3 = rbinom(n_test, 1, 0.5) )"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/prospective-power.html","id":"fitting-a-prognostic-model","dir":"Articles","previous_headings":"For linear models","what":"Fitting a prognostic model","title":"Prospective Power Estimation","text":"Using training part historical data, fit prognostic model using fit_best_learner() function. fits discrete super learner returns trained workflow, can use prediction construct prognostic scores.","code":"lrnr <- fit_best_learner(   data = train,   preproc = list(mod = Y ~ .),   cv_folds = 10,   verbose = 0 )  test <- dplyr::bind_cols(test, predict(lrnr, test))"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/prospective-power.html","id":"estimating-the-variance-used-for-power-approximation","dir":"Articles","previous_headings":"For linear models","what":"Estimating the variance used for power approximation","title":"Prospective Power Estimation","text":"use function variance_ancova estimate entity œÉ2(1‚àíR2)\\sigma^2(1-R^2) case ‚Äústandard‚Äù ANCOVA model adjusting covariates data, case ANCOVA utilising prognostic covariate adjustment adjusting prognostic score covariate.","code":"var_bound_ancova <- variance_ancova(Y ~ X1 + X2 + X3, data = test) var_bound_prog <- variance_ancova(Y ~ X1 + X2 + X3 + .pred, data = test)"},{"path":"https://novonordisk-opensource.github.io/postcard/articles/prospective-power.html","id":"creating-a-plot-of-power-curves","dir":"Articles","previous_headings":"For linear models","what":"Creating a plot of power curves","title":"Prospective Power Estimation","text":"order see estimated power behaves function total sample size, iterate power_gs function number different sample sizes save results using estimated variance without prognostic covariate adjustment. Note just use power_gs() function, power_nc() also available works exactly except needs additional mandatory argument df degrees freedom t-distribution. create plot estimated power across values sample sizes two different models, mark desired power 90% horizontal line create vertical lines labels show sample size needed obtain 90% power model. Note just interested finding sample size needed 90% power, simply running samplesize_gs() enough.","code":"desired_power <- 0.9 n_from <- 10 n_to <- 250  iterate_power <- function(variance) {   power_ancova <- sapply(n_from:n_to, FUN = function(n) power_gs(     n = n,     variance = variance,     r = 1, ate = .8, margin = 0   )   )   data.frame(n = n_from:n_to, power = power_ancova) }  data_power <- dplyr::bind_rows(   iterate_power(var_bound_ancova) %>%      dplyr::mutate(       n_desired = samplesize_gs(         variance = var_bound_ancova,         power = desired_power,         r = 1, ate = .8, margin = 0       ),       model = \"ancova\",       model_label = \"ANCOVA\"     ),   iterate_power(var_bound_prog) %>%      dplyr::mutate(       n_desired = samplesize_gs(         variance = var_bound_prog,         power = desired_power,         r = 1, ate = .8, margin = 0       ),       model = \"prog\",       model_label = \"ANCOVA with prognostic score\") ) model_cols <- c(ancova = \"darkorange1\", prog = \"dodgerblue4\")  show_npower <- function(data, coords) {   line <- grid::segmentsGrob(     x0 = coords$x, x1 = coords$x,     y0 = 0, y1 = coords$y,     gp = grid::gpar(       lty = \"dashed\",       col = data$colour     ))   group <- unique(data$group)   if (group == 1)      y_pos <- grid::unit(coords$y, \"npc\") - grid::unit(2, \"mm\")   else      y_pos <- grid::unit(0.55, \"npc\")   label <- grid::textGrob(     label = paste0(data$model_label, \": \", ceiling(data$x)),     x = grid::unit(coords$x, \"npc\") + grid::unit(2, \"mm\"),     y = y_pos,     just = c(0, 1),     gp = grid::gpar(col = data$colour)   )   grid::grobTree(line, label) }  data_power %>%   ggplot2::ggplot(ggplot2::aes(x = n, y = power, color = model)) +   ggplot2::geom_line(linewidth = 1.2, alpha = 0.8,                      show.legend = FALSE) +   ggplot2::geom_hline(     yintercept = desired_power,     color = \"grey40\",     linetype = \"dashed\"   ) +   gggrid::grid_group(     show_npower,     ggplot2::aes(x = n_desired,                  y = desired_power,                  model_label = model_label)   ) +   ggplot2::scale_color_manual(     name = \"\",     values = model_cols) +   ggplot2::scale_y_continuous(     breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1),     labels = function(x) paste0(x*100, \"%\")   ) +   ggplot2::labs(x = \"Total sample size\", y = \"Power\",                 title = \"Guenther Schouten approximation of power\") +   ggplot2::theme(plot.title = ggplot2::element_text(     face = \"bold\",     size = 16   )) +   ggplot2::theme_minimal()"},{"path":"https://novonordisk-opensource.github.io/postcard/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mathias Lerbech Jeppesen. Author, maintainer. Emilie Hojbjerre-Frandsen. Author. Novo Nordisk /S. Copyright holder.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jeppesen M, Hojbjerre-Frandsen E (2025). postcard: Estimating Marginal Effects Prognostic Covariate Adjustment. R package version 1.0.0.9000, https://novonordisk-opensource.github.io/postcard/.","code":"@Manual{,   title = {postcard: Estimating Marginal Effects with Prognostic Covariate Adjustment},   author = {Mathias Lerbech Jeppesen and Emilie Hojbjerre-Frandsen},   year = {2025},   note = {R package version 1.0.0.9000},   url = {https://novonordisk-opensource.github.io/postcard/}, }"},{"path":"https://novonordisk-opensource.github.io/postcard/index.html","id":"postcard","dir":"","previous_headings":"","what":"Estimating Marginal Effects with Prognostic Covariate Adjustment","title":"Estimating Marginal Effects with Prognostic Covariate Adjustment","text":"postcard provides tools accurately estimating marginal effects using plug-estimation GLMs, including increasing precision using prognostic covariate adjustment. See Powering RCTs marginal effects GLMs using prognostic score adjustment H√∏jbjerre-Frandsen et. al (2025).","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/index.html","id":"estimating-marginal-effects","dir":"","previous_headings":"","what":"Estimating marginal effects","title":"Estimating Marginal Effects with Prognostic Covariate Adjustment","text":"rctglm() used estimate marginal effects. See introductory examples usage vignette(\"postcard\") details vignette(\"model-fit\"). Marginal effects causal effects form r(Œ®1,Œ®0)r(\\Psi_1, \\Psi_0), Œ®a=ùîº[Y()]\\Psi_a=\\mathbb{E}[Y()] population mean outcomes exposure =0,1a=0, 1, respectively, rr estimand (function). Œ®a\\Psi_a sometimes referred counterfactual means. package uses plug-estimation robust estimation marginal effect estimand well influence functions robust estimation variance estimand (Rosenblum, M. M. J. van der Laan, 2010: Simple, efficient estimators treatment effects randomized trials using generalized linear models leverage baseline variables. International Journal Biostatistics, 6, . 1).","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/index.html","id":"prognostic-covariate-adjustment","dir":"","previous_headings":"","what":"Prognostic covariate adjustment","title":"Estimating Marginal Effects with Prognostic Covariate Adjustment","text":"rctglm_with_prognosticscore() used estimate marginal effects including use prognostic covariate adjustment. See introductory examples usage vignette(\"postcard\") details vignette(\"model-fit\"). Prognostic covariate adjustment involves training prognostic model historical data predict response data. Assuming historical data representative comparator group ‚Äúnew‚Äù data set, can use prognostic model predict comparator counterfactual outcome observations (including ones comparator group). prediction, called prognostic score, used adjustment covariate GLM.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/index.html","id":"power-approximation","dir":"","previous_headings":"","what":"Power approximation","title":"Estimating Marginal Effects with Prognostic Covariate Adjustment","text":"Implementations sample size/power approximation formulas available, enabling retrospective power analyses performed using package. Introductory examples available vignette(\"postcard\") details vignette(\"prospective-power\").","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/index.html","id":"when-estimating-marginal-effects-using-any-model","dir":"","previous_headings":"Power approximation","what":"When estimating marginal effects using any model","title":"Estimating Marginal Effects with Prognostic Covariate Adjustment","text":"method estimating power case estimating marginal effects described reference top page, algorithm implemented function power_marginaleffect.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/index.html","id":"specifically-for-linear-models","dir":"","previous_headings":"Power approximation","what":"Specifically for linear models","title":"Estimating Marginal Effects with Prognostic Covariate Adjustment","text":"Functionalities available estimate power linear models include functions variance_ancova, power_gs, samplesize_gs, power_nc.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimating Marginal Effects with Prognostic Covariate Adjustment","text":"install package:","code":"install.packages(\"postcard\")  # Development version: # install.packages(\"pak\") pak::pak(\"NovoNordisk-OpenSource/postcard\")"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/default_learners.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a list of learners ‚Äî default_learners","title":"Creates a list of learners ‚Äî default_learners","text":"function creates list learners compatible learners argument fit_best_learner, used default argument.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/default_learners.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a list of learners ‚Äî default_learners","text":"","code":"default_learners()"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/default_learners.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a list of learners ‚Äî default_learners","text":"named list learners, element consists model: parsnip model specification grid: data.frame columns corresponding tuning parameters","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/default_learners.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a list of learners ‚Äî default_learners","text":"","code":"default_learners() #> $mars #> $mars$model #> MARS Model Specification (regression) #>  #> Main Arguments: #>   prod_degree = 3 #>  #> Computational engine: earth  #>  #>  #>  #> $lm #> $lm$model #> Linear Regression Model Specification (regression) #>  #> Computational engine: lm  #>  #>  #>  #> $gbt #> $gbt$model #> Boosted Tree Model Specification (regression) #>  #> Main Arguments: #>   trees = parsnip::tune(\"trees\") #>   tree_depth = parsnip::tune(\"tree_depth\") #>   learn_rate = 0.1 #>  #> Computational engine: xgboost  #>  #>  #> $gbt$grid #>    trees tree_depth #> 1     25          3 #> 2     50          3 #> 3     75          3 #> 4    100          3 #> 5    125          3 #> 6    150          3 #> 7    175          3 #> 8    200          3 #> 9    225          3 #> 10   250          3 #> 11   275          3 #> 12   300          3 #> 13   325          3 #> 14   350          3 #> 15   375          3 #> 16   400          3 #> 17   425          3 #> 18   450          3 #> 19   475          3 #> 20   500          3 #>  #>"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/fit_best_learner.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"Find best learner terms RMSE among specified learners using cross validation","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/fit_best_learner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"","code":"fit_best_learner(   preproc,   data,   cv_folds = 5,   learners = default_learners(),   verbose = options::opt(\"verbose\") )"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/fit_best_learner.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"preproc list (preferably named) preprocessing objects: formulas, recipes, workflows::workflow_variables(). Passed workflowsets::workflow_set(). data data frame. cv_folds numeric number cross-validation folds used fitting evaluating models learners list (preferably named) containing named lists elements model optionally grid. model element parsnip model specification, passed workflowsets::workflow_set model argument, grid element passed grid argument workflowsets::option_add verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE')","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/fit_best_learner.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"trained workflow","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/fit_best_learner.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"Ensure data compatibility learners.","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/reference/fit_best_learner.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"","code":"# Generate some synthetic 2-armed RCT data along with historical controls n <- 100 dat_rct <- glm_data(   Y ~ 1+2*x1+3*a,   x1 = rnorm(n, 2),   a = rbinom (n, 1, .5),   family = gaussian() ) dat_hist <- glm_data(   Y ~ 1+2*x1,   x1 = rnorm(n, 2),   family = gaussian() )  # Fit a learner to the historical control data learners <- list(   mars = list(     model = parsnip::set_engine(       parsnip::mars(         mode = \"regression\", prod_degree = 3       ),       \"earth\"     )   ) ) fit <- fit_best_learner(   preproc = list(mod = Y ~ .),   data = dat_hist,   learners = learners ) #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 1 of 1 resampling: mod_mars #> ‚úî 1 of 1 resampling: mod_mars (184ms) #> ‚Ñπ Model with lowest RMSE: mod_mars  # Use it fx. to predict the \"control outcome\" in the 2-armed RCT predict(fit, new_data = dat_rct) #> # A tibble: 100 √ó 1 #>     .pred #>     <dbl> #>  1  2.17  #>  2  5.54  #>  3 -0.219 #>  4  5.04  #>  5  6.23  #>  6  7.22  #>  7  1.20  #>  8  4.59  #>  9  4.59  #> 10  4.52  #> # ‚Ñπ 90 more rows"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/glm_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate data simulated from a GLM ‚Äî glm_data","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"Provide formula, variables family generate linear predictor using formula provided variables using inverse link family generate GLM modelled mean, mu, used simulate response mean generating function according chosen family.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/glm_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"","code":"glm_data(formula, ..., family = gaussian(), family_args = list(sd = 1))"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/glm_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"formula object class \"formula\" (one can coerced class): symbolic description model fitted. details model specification given ‚ÄòDetails‚Äô glm documentation. ... data.frame columns corresponding variables used formula, named list variables, individually provided named arguments variables family family response. can character string naming family function, family function result call family function family_args named list values arguments passed family relevant r<family_name> function simulating data","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/glm_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"data.frame","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/glm_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"","code":"# Generate a gaussian response from a single covariate glm_data(Y ~ 1+2*x1,                 x1 = rnorm(10)) #>            Y          x1 #> 1  -1.449147 -0.89480241 #> 2   2.865960  0.90426912 #> 3  -1.648712  0.07964921 #> 4  -2.429914 -1.25882722 #> 5   2.268991  1.02568511 #> 6  -1.125662 -0.73077860 #> 7   1.246019 -0.19014551 #> 8   1.550481  0.52886469 #> 9   2.370782  0.55021053 #> 10  2.566846  0.54968434  # Generate a gaussian response from a single covariate with non-linear # effects. Specify that the response should have standard deviation sqrt(3) glm_data(Y ~ 1+2*abs(sin(x1)),                 x1 = runif(10, min = -2, max = 2),                 family_args = list(sd = sqrt(3))) #>            Y         x1 #> 1  5.8875239  1.0618623 #> 2  1.8274380  0.5078665 #> 3  4.9617796  0.9213538 #> 4  0.5141856 -0.3051824 #> 5  2.2240450 -0.9266769 #> 6  1.5760863  1.0761921 #> 7  0.9143955  0.3493867 #> 8  4.0499201  1.5942710 #> 9  4.0731122  1.4812982 #> 10 0.5794237 -0.4027751  # Generate a negative binomial response glm_data(Y ~ 1+2*x1-x2,                 x1 = rnorm(10),                 x2 = rgamma(10, shape = 2),                 family = MASS::negative.binomial(2)) #>     Y         x1        x2 #> 1   0 -0.7836391 2.3050987 #> 2   1 -0.9531239 1.3214499 #> 3   0  1.7927561 3.7469426 #> 4   0  0.3489767 1.8461783 #> 5   2  0.2591038 2.0354566 #> 6   0 -0.8059519 0.6438993 #> 7   4  0.1056647 0.7646888 #> 8   2 -0.3335997 0.9691220 #> 9  20  1.6418480 0.6479179 #> 10  0 -0.6439059 0.5980742  # Provide variables as a list/data.frame glm_data(resp ~ 1+2*x1-x2,                 data.frame(                   x1 = rnorm(10),                   x2 = rgamma(10, shape = 2)                 ),                 family = MASS::negative.binomial(2)) #>    resp          x1        x2 #> 1     0 -0.05367151 2.0555178 #> 2     0 -0.56352463 4.8979183 #> 3     0 -0.74390896 0.9440099 #> 4     0 -0.10904165 0.3404743 #> 5     0 -0.56082923 2.1408569 #> 6     0  0.18800155 0.6841673 #> 7     1  0.74885094 1.8483538 #> 8     0 -1.91653832 0.6336780 #> 9     2  0.23609585 0.2305099 #> 10    2  0.62895342 1.4685068"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/options.html","id":null,"dir":"Reference","previous_headings":"","what":"postcard Options ‚Äî options","title":"postcard Options ‚Äî options","text":"Internally used, package-specific options. options prioritize R options() values, fall back environment variables undefined. neither option environment variable set, default value used.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"postcard Options ‚Äî options","text":"verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE')","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/options.html","id":"checking-option-values","dir":"Reference","previous_headings":"","what":"Checking Option Values","title":"postcard Options ‚Äî options","text":"Option values specific postcard can accessed passing package name env.","code":"options::opts(env = \"postcard\")  options::opt(x, default, env = \"postcard\")"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/options.html","id":"options","dir":"Reference","previous_headings":"","what":"Options","title":"postcard Options ‚Äî options","text":"verbose default: 2 option: postcard.verbose envvar: R_POSTCARD_VERBOSE (evaluated possible, raw string otherwise)","code":"2"},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/reference/postcard-package.html","id":null,"dir":"Reference","previous_headings":"","what":"postcard: Estimating Marginal Effects with Prognostic Covariate Adjustment ‚Äî postcard-package","title":"postcard: Estimating Marginal Effects with Prognostic Covariate Adjustment ‚Äî postcard-package","text":"Conduct power analyses inference marginal effects. Uses plug-estimation influence functions perform robust inference, optionally leveraging historical data increase precision prognostic covariate adjustment. methods described H√∏jbjerre-Frandsen et al. (2025) doi:10.48550/arXiv.2503.22284 .","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/reference/postcard-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"postcard: Estimating Marginal Effects with Prognostic Covariate Adjustment ‚Äî postcard-package","text":"Maintainer: Mathias Lerbech Jeppesen mathiasljeppesen@outlook.com Authors: Emilie Hojbjerre-Frandsen ehfd@novonordisk.com contributors: Novo Nordisk /S [copyright holder]","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Power and sample size estimation for linear models ‚Äî power_linear","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"variance_ancova provides convenient function estimating variance use power sample size approximation. power_gs samplesize_gs functions calculate Guenther-Schouten power approximation ANOVA ANCOVA. approximation based (Guenther WC. Sample Size Formulas Normal Theory T Tests. American Statistician. 1981;35(4):243‚Äì244) (Schouten HJA. Sample size formula continuous outcome unequal group sizes unequal variances. Statistics Medicine. 1999;18(1):87‚Äì91). function power_nc calculates power ANOVA ANCOVA based non-centrality parameter exact t-distributions. See details function Details sections Value.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"","code":"variance_ancova(formula, data, inflation = 1, deflation = 1)  power_gs(variance, ate, n, r = 1, margin = 0, alpha = 0.025)  samplesize_gs(variance, ate, r = 1, margin = 0, power = 0.9, alpha = 0.025)  power_nc(variance, df, ate, n, r = 1, margin = 0, alpha = 0.025)"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"formula object class \"formula\" (one can coerced class): symbolic description used stats::model.frame() create data.frame response covariates. data.frame used estimate \\(R^2\\), used find variance. See details. data data frame, list environment (object     coercible .data.frame data frame),     containing variables formula.  Neither matrix     array accepted. inflation numeric multiply marginal variance response . Default 1 estimates variance directly data. Use values 1 obtain conservative estimate marginal response variance. deflation numeric multiply \\(R^2\\) . Default 1 means estimate \\(R^2\\) unchanged. Use values 1 obtain conservative estimate coefficient determination. See details \\(R^2\\) related estimation. variance numeric variance use approximation. See details documentation sections power approximating function. ate numeric minimum effect size able detect. n numeric number participants total. number participants treatment group \\(n1=(r/(1+r))n\\) control group \\(n1=(1/(1+r))n\\). r numeric allocation ratio \\(r=n1/n0\\). one--one randomisation r=1. margin numeric superiority margin (non-inferiority margin, negative value can provided). alpha numeric significance level. Due regulatory guidelines using one-sided test, half specified significance level used. Thus, standard significance level 5%, default alpha = 0.025. power numeric giving desired power calculating sample size df numeric degrees freedom use t-distribution.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"functions return numeric. variance_ancova returns numeric variance estimated data used power estimation sample size estimation. power_xx samplesize_xx functions return numeric power sample size approximation.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"details section provides information relation arguments functions formulas described sections power approximation formula. Note entities carry name argument formula mentioned , obviously linked (n, r, alpha) ate: \\(\\beta_1-\\beta_0\\) margin: \\(\\Delta_s\\) variance: \\(\\widehat{\\sigma}^2(1-\\widehat{R}^2)\\)","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":"finding-the-variance-to-use-for-approximation","dir":"Reference","previous_headings":"","what":"Finding the variance to use for approximation","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"variance_ancova function estimates \\(\\sigma^2(1-R^2)\\) data returns numeric can passed directly variance power_gs. Corresponds estimating power using lm formula specified variance_ancova. user can estimate variance way see fit.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":"guenther-schouten-power-approximation","dir":"Reference","previous_headings":"","what":"Guenther-Schouten power approximation","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"estimation formula case ANCOVA model multiple covariate adjustment (see description reference): $$ n=\\frac{(1+r)^2}{r}\\frac{(z_{1-\\alpha}+z_{1-\\beta})^2\\widehat{\\sigma}^2(1-\\widehat{R}^2)}{(\\beta_1-\\beta_0-\\Delta_s)^2}+\\frac{(z_{1-\\alpha})^2}{2} $$ \\(\\widehat{R}^2= \\frac{\\widehat{\\sigma}_{XY}^\\top \\widehat{\\Sigma}_X^{-1}\\widehat{\\sigma}_{XY}}{\\widehat{\\sigma}^2}\\), denote \\(\\widehat{\\sigma^2}\\) estimate variance outcome, \\(\\widehat{\\Sigma_X}\\) estimate covariance matrix covariates, \\(\\widehat{\\sigma_{XY}}\\) \\(p\\)-dimensional column vector consisting estimate covariance outcome variable covariate. univariate case \\(R^2\\) replaced \\(\\rho^2\\)","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":"power-approximation-using-non-centrality-parameter","dir":"Reference","previous_headings":"","what":"Power approximation using non-centrality parameter","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"prospective power estimations based (Kieser M. Methods Applications Sample Size Calculation Recalculation Clinical Trials. Springer; 2020). ANOVA power calculated based non-centrality parameter given $$nc =\\sqrt{\\frac{r}{(1+r)^2}\\cdot n}\\cdot\\frac{\\beta_1-\\beta_0-\\Delta_s}{\\sigma},$$ denote \\(\\sigma^2\\) variance outcome, power can estimated $$1-\\beta = 1 - F_{t,n-2,nc}\\left(F_{t, n-2, 0}^{-1}(1-\\alpha)\\right).$$ power ANCOVA univariate covariate adjustment interaction calculated based non-centrality parameter given $$nc =\\sqrt{\\frac{rn}{(1+r)^2}}\\frac{\\beta_1-\\beta_0-\\Delta_s}{\\sigma\\sqrt{1-\\rho^2}},$$ power can estimated $$1-\\beta = 1 - F_{t,n-3,nc}\\left(F_{t, n-3, 0}^{-1}(1-\\alpha)\\right).$$ power ANCOVA either univariate covariate adjustment interaction multiple covariate adjustement without interaction calculated based non-centrality parameter given $$nc =\\frac{\\beta_1-\\beta_0-\\Delta_s}{\\sqrt{\\left(\\frac{1}{n_1}+\\frac{1}{n_0} + X_d^\\top\\left((n-2)\\Sigma_X\\right)^{-1}X_d \\right)\\sigma^2\\left(1-\\widehat{R}^2\\right)}}.$$ \\(X_d = \\left(\\overline{X}_1^1-\\overline{X}_0^1, \\ldots, \\overline{X}_1^p-\\overline{X}_0^p\\right)^\\top\\), \\(\\widehat{R}^2= \\frac{\\widehat{\\sigma}_{XY}^\\top \\widehat{\\Sigma}_X^{-1}\\widehat{\\sigma}_{XY}}{\\widehat{\\sigma}^2}\\), denote \\(\\widehat{\\sigma^2}\\) estimate variance outcome, \\(\\widehat{\\Sigma_X}\\) estimate covariance matrix covariates, \\(\\widehat{\\sigma_{XY}}\\) \\(p\\)-dimensional column vector consisting estimate covariance outcome variable covariate. Since case randomized trials expected difference covariate values groups 0. Furthermore, elements \\(\\Sigma_X^{-1}\\) small, unless variances close 0, covariates exhibit strong linear dependencies, correlations close 1. scenarios excluded since lead potentially serious problems regarding inference either way. arguments used Zimmermann et. al (Zimmermann G, Kieser M, Bathke AC. Sample Size Calculation Blinded Recalculation Analysis Covariance Models Multiple Random Covariates. Journal Biopharmaceutical Statistics. 2020;30(1):143‚Äì159.) approximate non-centrality parameter univariate case \\(\\rho^2\\) replaced \\(R^2\\). power ANCOVA d degrees freedom can estimated $$1-\\beta = 1 - F_{t,d,nc}\\left(F_{t, d,0), 0}^{-1}(1-\\alpha)\\right).$$","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power and sample size estimation for linear models ‚Äî power_linear","text":"","code":"# Generate a data set to use as an example dat_gaus <- glm_data(Y ~ 1+2*X1-X2+3*A,                 X1 = rnorm(100),                 X2 = rgamma(100, shape = 2),                 A = rbinom(100, size = 1, prob = 0.5),                 family = gaussian())  # Approximate the power using no adjustment covariates va_nocov <- var(dat_gaus$Y) power_gs(n = 200, variance = va_nocov, ate = 1) #> [1] 0.6059117  # Approximate the power with a model adjusting for both variables in the # data generating process  ## First estimate the variance sigma^2 * (1-R^2) va_cov <- variance_ancova(Y ~ X1 + X2 + A, dat_gaus) ## Then estimate the power using this variance power_gs(n = 100, variance = va_cov, ate = 1.8, margin = 1, r = 2) #> [1] 0.9592429  # Approximate the sample size needed to obtain 90% power with same model as # above samplesize_gs(   variance = va_cov, ate = 1.8, power = 0.9, margin = 1, r = 2 ) #> [1] 77.12053  # No adjustment covariates power_nc(n = 200, variance = va_nocov, df = 199, ate = 1) #> [1] 0.6058972 # Adjusting for all covariates in data generating process power_nc(n = 200, variance = va_cov, df = 196, ate = 1.8, margin = 1, r = 2) #> [1] 0.9995171"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_marginaleffect.html","id":null,"dir":"Reference","previous_headings":"","what":"Power approximation for estimating marginal effects in GLMs ‚Äî power_marginaleffect","title":"Power approximation for estimating marginal effects in GLMs ‚Äî power_marginaleffect","text":"functions implements algorithm power estimation described Powering RCTs marginal effects GLMs using prognostic score adjustment H√∏jbjerre-Frandsen et. al (2025). See bit context details details reference.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_marginaleffect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power approximation for estimating marginal effects in GLMs ‚Äî power_marginaleffect","text":"","code":"power_marginaleffect(   response,   predictions,   target_effect,   exposure_prob,   var1 = NULL,   kappa1_squared = NULL,   estimand_fun = \"ate\",   estimand_fun_deriv0 = NULL,   estimand_fun_deriv1 = NULL,   inv_estimand_fun = NULL,   margin = estimand_fun(1, 1),   alpha = 0.025,   tolerance = 0.001,   verbose = options::opt(\"verbose\"),   ... )"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_marginaleffect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power approximation for estimating marginal effects in GLMs ‚Äî power_marginaleffect","text":"response response variable comparator participants predictions predictions response target_effect numeric minimum effect size able detect. See details. exposure_prob numeric probability \"group 1\" (rather group 0). See details. var1 numeric variance potential outcome corresponding group 1, function single argument meant obtain var1 tranformation variance potential outcome corresponding group 0. See details. kappa1_squared numeric mean-squared error predicting potential outcome corresponding group 1, function single arguments meant obtain kappa1_squared transformation MSE group 0. See details. estimand_fun function arguments psi1 psi0 specifying estimand. Alternative, specify \"ate\" \"rate_ratio\" character use one default estimand functions. See details \"Estimand\" section rctglm. estimand_fun_deriv0 function specifying derivative estimand_fun wrt. psi0. default algorithm use symbolic differentiation automatically find derivative estimand_fun estimand_fun_deriv1 function specifying derivative estimand_fun wrt. psi1. default algorithm use symbolic differentiation automatically find derivative estimand_fun inv_estimand_fun (optional) function arguments psi0 target_effect, estimand_fun(psi1 = y, psi0 = x) = z inv_estimand_fun(psi0 = x, target_effect = z) = y x, y, z. left NULL, inverse found automatically margin numeric superiority margin. default, estimand_fun evaluated counterfactual means psi1 psi0, corresponding superiority margin assuming difference (fx. 0 ATE 1 rate ratio). alpha numeric significance level. Due regulatory guidelines using one-sided test, half specified significance level used. Thus, standard significance level 5%, default alpha = 0.025. tolerance passed .equal comparing calculated target_effect derivations given target_effect. verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE') ... arguments passed [stats::uniroot], used find inverse estimand_fun, inv_estimand_fun NULL.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_marginaleffect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power approximation for estimating marginal effects in GLMs ‚Äî power_marginaleffect","text":"numeric estimated power.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_marginaleffect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power approximation for estimating marginal effects in GLMs ‚Äî power_marginaleffect","text":"reference description shows \"Prospective power\" section derivation variance bound $$ v_\\infty^{\\uparrow 2} = r_0'^{\\, 2}\\sigma_0^2+ r_1'^{\\, 2}\\sigma_1^2+ \\pi_0\\pi_1\\left(\\frac{|r_0'|\\kappa_0}{\\pi_0} + \\frac{|r_1'|\\kappa_1}{\\pi_1} \\right)^2 $$ \\(r_a'\\) derivative estimand_fun respect \\(\\Psi_a\\), \\(\\sigma_a^2\\) variance potential outcome corresponding group \\(\\), \\(\\pi_a\\) probability assigned group \\(\\), \\(\\kappa_a\\) expected mean-squared error predicting potential outcome corresponding group \\(\\). variance bound used calculating lower bound power using distributions corresponding null alternative hypotheses \\(\\mathcal{H}_0: \\hat{\\Psi} \\sim F_0 = \\mathcal{N}(\\Delta ,v_\\infty^{\\uparrow 2} / n)\\) \\(\\mathcal{H}_1: \\hat{\\Psi} \\sim F_1 = \\mathcal{N}(\\Psi,v_\\infty^{\\uparrow 2} / n)\\). See details reference.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_marginaleffect.html","id":"relating-arguments-to-formulas","dir":"Reference","previous_headings":"","what":"Relating arguments to formulas","title":"Power approximation for estimating marginal effects in GLMs ‚Äî power_marginaleffect","text":"response: Used obtain \\(\\sigma_0^2\\) (taking sample variance response) \\(\\kappa_0\\). predictions: Used calculating MSE \\(\\kappa_0\\). var1: \\(\\sigma_1^2\\). default, chosen \\(\\sigma_0^2\\). Can specify differently argument fx. Inflating deflating value \\(\\sigma_0^2\\) scalar according prior beliefs. Fx. specify var1 = function(x) 1.2 * x inflate \\(\\sigma_0^2\\) 1.2. historical data available group 1, estimate variance data can provided . kappa1_squared: \\(\\kappa_1\\). var1, default assume value kappa0_squared, found using response predictions vectors. Adjust value according prior beliefs relevant. target_effect: \\(\\Psi\\). exposure_prob: \\(\\pi_1\\)","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/reference/power_marginaleffect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power approximation for estimating marginal effects in GLMs ‚Äî power_marginaleffect","text":"","code":"# Generate a data set to use as an example n <- 100 exposure_prob <- .5  dat_gaus <- glm_data(Y ~ 1+2*X1-X2+3*A+1.6*A*X2,                 X1 = rnorm(n),                 X2 = rgamma(n, shape = 2),                 A = rbinom(n, size = 1, prob = exposure_prob),                 family = gaussian())  # --------------------------------------------------------------------------- # Obtain out-of-sample (OOS) prediction using glm model # --------------------------------------------------------------------------- gaus1 <- dat_gaus[1:(n/2), ] gaus2 <- dat_gaus[(n/2+1):n, ]  glm1 <- glm(Y ~ X1 + X2 + A, data = gaus1) glm2 <- glm(Y ~ X1 + X2 + A, data = gaus2) preds_glm1 <- predict(glm2, newdata = gaus1, type = \"response\") preds_glm2 <- predict(glm1, newdata = gaus2, type = \"response\") preds_glm <- c(preds_glm1, preds_glm2)  # Obtain power power_marginaleffect(   response = dat_gaus$Y,   predictions = preds_glm,   target_effect = 2,   exposure_prob = exposure_prob ) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` #> [1] 0.9151848  # --------------------------------------------------------------------------- # Get OOS predictions using discrete super learner and adjust variance # --------------------------------------------------------------------------- learners <- list(   mars = list(     model = parsnip::set_engine(       parsnip::mars(         mode = \"regression\", prod_degree = 3       ),       \"earth\"     )  ),     lm = list(       model = parsnip::set_engine(         parsnip::linear_reg(),         \"lm\"       )     ) ) lrnr1 <- fit_best_learner(preproc = list(mod = Y ~ X1 + X2 + A),                           data = gaus1,                           learners = learners) #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 1 of 2 resampling: mod_mars #> ‚úî 1 of 2 resampling: mod_mars (129ms) #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 2 of 2 resampling: mod_lm #> ‚úî 2 of 2 resampling: mod_lm (97ms) #> ‚Ñπ Model with lowest RMSE: mod_mars lrnr2 <- fit_best_learner(preproc = list(mod = Y ~ X1 + X2 + A),                           data = gaus2,                           learners = learners) #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 1 of 2 resampling: mod_mars #> ‚úî 1 of 2 resampling: mod_mars (131ms) #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 2 of 2 resampling: mod_lm #> ‚úî 2 of 2 resampling: mod_lm (97ms) #> ‚Ñπ Model with lowest RMSE: mod_lm preds_lrnr1 <- dplyr::pull(predict(lrnr2, new_data = gaus1)) preds_lrnr2 <- dplyr::pull(predict(lrnr1, new_data = gaus2)) preds_lrnr <- c(preds_lrnr1, preds_lrnr2)  # Estimate the power AND adjust the assumed variance in the \"unknown\" # group 1 to be 20% larger than in group 0 power_marginaleffect(   response = dat_gaus$Y,   predictions = preds_lrnr,   target_effect = 2,   exposure_prob = exposure_prob,   var1 = function(var0) 1.2 * var0 ) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` #> [1] 0.90812"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/prog.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract information about the fitted prognostic model ‚Äî prog","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"Extracts prognostic_info list element rctglm_prog object. See 'Value' rctglm_with_prognosticscore details.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/prog.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"","code":"prog(x)  # S3 method for class 'rctglm_prog' prog(x)"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/prog.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"x object class rctglm_prog (returned rctglm_with_prognosticscore)","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/prog.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"list structure described prognostic_info Value section rctglm_with_prognosticscore.","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/reference/prog.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"","code":"# Generate some data n <- 100 b0 <- 1 b1 <- 1.5 b2 <- 2 W1 <- runif(n, min = -2, max = 2) exposure_prob <- .5  dat_treat <- glm_data(   Y ~ b0+b1*abs(sin(W1))+b2*A,   W1 = W1,   A = rbinom(n, 1, exposure_prob) )  dat_notreat <- glm_data(   Y ~ b0+b1*abs(sin(W1)),   W1 = W1 )  learners <- list(   mars = list(     model = parsnip::set_engine(       parsnip::mars(         mode = \"regression\", prod_degree = 3       ),       \"earth\"     )   ) ) ate <- rctglm_with_prognosticscore(   formula = Y ~ .,   exposure_indicator = A,   exposure_prob = exposure_prob,   data = dat_treat,   family = gaussian(),   estimand_fun = \"ate\",   data_hist = dat_notreat,   learners = learners) #>  #> ‚îÄ‚îÄ Fitting prognostic model ‚îÄ‚îÄ #>  #> ‚Ñπ Created formula for fitting prognostic model as: Y ~ . #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 1 of 1 resampling: mod_mars #> ‚úî 1 of 1 resampling: mod_mars (126ms) #> ‚Ñπ Model with lowest RMSE: mod_mars #> ‚Ñπ Investigate trained learners and fitted model in `prognostic_info` list element #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  prog(ate) #> $formula #> Y ~ . #> <environment: 0x5563e09b00e0> #>  #> $model_fit #> ‚ïê‚ïê Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Formula #> Model: mars() #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Y ~ . #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Selected 3 of 8 terms, and 1 of 1 predictors #> Termination condition: RSq changed by less than 0.001 at 8 terms #> Importance: W1 #> Number of terms at each degree of interaction: 1 2 (additive model) #> GCV 1.026029    RSS 90.65992    GRSq 0.1592515    RSq 0.242031 #>  #> $learners #> $learners$mars #> $learners$mars$model #> MARS Model Specification (regression) #>  #> Main Arguments: #>   prod_degree = 3 #>  #> Computational engine: earth  #>  #>  #>  #>  #> $cv_folds #> [1] 5 #>  #> $data #>                Y           W1 #> 1    1.080226520  0.054207169 #> 2    0.073091604 -0.148972606 #> 3    3.463991365 -1.553011931 #> 4    2.095647164  0.477838799 #> 5    1.548042412  0.782236281 #> 6    1.086007249 -0.732574321 #> 7    2.881073546  1.516755318 #> 8    2.591274753 -0.381372944 #> 9    1.900611511  0.539134447 #> 10   3.276913163  1.180297946 #> 11   1.439599522  0.835140067 #> 12   2.548099724 -1.760414447 #> 13   4.755088192 -1.321984500 #> 14   1.255413214  0.148989349 #> 15   1.626508656  0.482557669 #> 16   2.328459792 -0.572686500 #> 17   2.610934937  0.145828577 #> 18   2.325281944 -0.205931618 #> 19   2.499078380 -1.301826689 #> 20   2.467808292  0.633152368 #> 21   1.831622059  1.886640927 #> 22   1.785702057 -0.881517597 #> 23   0.325903648  0.522782093 #> 24   0.312511589 -0.306786704 #> 25   3.222912589 -0.689656083 #> 26   1.338352104 -0.424981941 #> 27   2.666737727  0.527979673 #> 28   3.180142896  0.117435311 #> 29   2.718007789  1.373388373 #> 30   1.365376059  0.558169925 #> 31   0.198253454  1.970081693 #> 32   1.989264654  0.835948863 #> 33   2.560533844  1.013648397 #> 34   0.720241235  0.061265321 #> 35   3.286797130  0.455773049 #> 36   2.775621326 -1.785018779 #> 37  -0.242777378 -0.215847690 #> 38   1.250574461 -1.412297177 #> 39  -0.008274275 -0.243686806 #> 40   2.516194692  1.919667291 #> 41   2.074303752 -1.381230622 #> 42   1.061268332  0.280097803 #> 43   1.380980681 -0.097808911 #> 44   4.263829485  1.481619725 #> 45   2.340778266 -0.629327535 #> 46   3.078616618  0.672877684 #> 47   0.963857061 -1.011671729 #> 48   1.168146476  0.833760550 #> 49   2.223499098  1.073705474 #> 50   1.103263367  0.965277493 #> 51   0.998553330 -1.817015395 #> 52   0.720258064  1.240615459 #> 53   0.509434600  0.523799929 #> 54   0.723838361  0.548520023 #> 55   1.344597724 -0.822208690 #> 56   0.534112449  0.079563512 #> 57   3.032321333  1.384982192 #> 58   2.375438852  1.193408270 #> 59   2.300375597 -1.369564363 #> 60   2.939245436 -0.443691538 #> 61  -0.146371012 -0.187557026 #> 62   4.118867764 -1.142904804 #> 63  -0.083051780  0.759210528 #> 64   2.013660862  0.002638961 #> 65   2.630543689  1.980248458 #> 66   2.121195516 -1.529962860 #> 67   2.811296125  1.857370362 #> 68   0.341607582  0.565919823 #> 69   3.403676539 -1.564187960 #> 70   1.545973392 -0.834586513 #> 71   0.875589490 -0.103746382 #> 72   3.440435040  1.023317943 #> 73   2.372142479 -1.483048798 #> 74   0.547463922 -0.097032987 #> 75   1.806742066  1.181269797 #> 76   2.618199762 -1.534684835 #> 77   2.519479860  0.893202768 #> 78   1.135825470 -0.190888042 #> 79   2.697688442 -0.981938925 #> 80   2.032643713 -1.042243558 #> 81   1.807305933  0.095488627 #> 82   4.448819143 -1.788098332 #> 83   1.892900503 -1.417561601 #> 84   2.451688328  0.759996420 #> 85   2.746144453  1.353978418 #> 86   0.498685704  1.612627343 #> 87   2.899097178 -1.646279992 #> 88   3.829616389 -1.787805090 #> 89   3.402060386 -1.478330033 #> 90   1.860861057 -1.577669651 #> 91   1.331898944  0.363677772 #> 92   2.559098593  1.772761269 #> 93   3.567000753 -1.388085473 #> 94   1.612616554  1.579245754 #> 95   3.871561423 -1.446541916 #> 96   1.738874250 -0.331721296 #> 97   2.022907515 -1.641866679 #> 98   2.779670580 -0.954397969 #> 99   1.966136555 -0.561635143 #> 100  1.616736057  0.620070576 #>"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"procedure uses plug--estimation influence functions perform robust inference specified estimand setting randomised clinical trial, even case heterogeneous effect covariates randomisation groups. See Powering RCTs marginal effects GLMs using prognostic score adjustment H√∏jbjerre-Frandsen et. al (2025) details methodology.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"","code":"rctglm(   formula,   exposure_indicator,   exposure_prob,   data,   family = gaussian,   estimand_fun = \"ate\",   estimand_fun_deriv0 = NULL,   estimand_fun_deriv1 = NULL,   cv_variance = FALSE,   cv_variance_folds = 10,   verbose = options::opt(\"verbose\"),   ... )"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"formula object class \"formula\" (one can coerced class): symbolic description model fitted. details model specification given ‚ÄòDetails‚Äô glm documentation. exposure_indicator (name ) binary variable data identifies randomisation groups. variable required binary make \"orientation\" estimand_fun clear. exposure_prob numeric probability \"group 1\" (rather group 0) groups defined exposure_indicator. data optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found data, variables taken environment(formula), typically environment function called. family description error distribution link     function used model.  glm can     character string naming family function, family function     result call family function.  glm.fit     third option supported.  (See family details     family functions.) estimand_fun function arguments psi1 psi0 specifying estimand. Alternative, specify \"ate\" \"rate_ratio\" character use one default estimand functions. See details \"Estimand\" section rctglm. estimand_fun_deriv0 function specifying derivative estimand_fun wrt. psi0. default algorithm use symbolic differentiation automatically find derivative estimand_fun estimand_fun_deriv1 function specifying derivative estimand_fun wrt. psi1. default algorithm use symbolic differentiation automatically find derivative estimand_fun cv_variance logical determining whether estimate variance using cross-validation (see details rctglm). cv_variance_folds numeric number folds use cross validation cv_variance TRUE. verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE') ... Additional arguments passed stats::glm()","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"rctglm returns object class inheriting \"rctglm\". object class rctglm list containing following components: estimand: data.frame plug-estimate estimand, standard error (SE) estimate variance estimate estimand estimand_funs: list f: estimand_fun used obtain estimate estimand counterfactual means d0: derivative respect psi0 d1: derivative respect psi1 means_counterfactual: data.frame counterfactual means psi0 psi1 fitted.values_counterfactual: data.frame counterfactual mean values, obtained transforming linear predictors group inverse link function. glm: glm object returned running stats::glm within procedure call: matched call","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"procedure assumes setup randomised clinical trial observations grouped binary exposure_indicator variable, allocated randomly probability exposure_prob. GLM fit used predict response observations event exposure_indicator 0 1, respectively. Taking means predictions produce counterfactual means psi0 psi1, estimand r(psi0, psi1) calculated using specified estimand_fun. variance estimand found taking variance influence function estimand. cv_variance TRUE, counterfactual predictions observation (used calculate value influence function) obtained --sample (OOS) predictions using cross validation number folds specified cv_variance_folds. cross validation splits performed using stratified sampling exposure_indicator strata argument rsample::vfold_cv. Read vignette(\"model-fit\").","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm.html","id":"estimands","dir":"Reference","previous_headings":"","what":"Estimands","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"noted description, psi0 psi1 counterfactual means found prediction using fitted GLM binary groups defined exposure_indicator. Default estimand functions can specified via \"ate\" (uses function function(psi1, psi0) psi1-psi0) \"rate_ratio\" (uses function function(psi1, psi0) psi1/psi0). See information specifying estimand_fun vignette(\"model-fit\"). default, Deriv package used perform symbolic differentiation find derivatives estimand_fun.","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"","code":"# Generate some data to showcase example n <- 100 exp_prob <- .5  dat_gaus <- glm_data(   Y ~ 1+1.5*X1+2*A,   X1 = rnorm(n),   A = rbinom(n, 1, exp_prob),   family = gaussian() )  # Fit the model ate <- rctglm(formula = Y ~ .,               exposure_indicator = A,               exposure_prob = exp_prob,               data = dat_gaus,               family = gaussian) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  # Pull information on estimand estimand(ate) #>   Estimate Std. Error #> 1 1.990445   0.197611  ## Another example with different family and specification of estimand_fun dat_binom <- glm_data(   Y ~ 1+1.5*X1+2*A,   X1 = rnorm(n),   A = rbinom(n, 1, exp_prob),   family = binomial() )  rr <- rctglm(formula = Y ~ .,               exposure_indicator = A,               exposure_prob = exp_prob,               data = dat_binom,               family = binomial(),               estimand_fun = \"rate_ratio\") #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1/psi0' with respect to 'psi0' as: '-(psi1/psi0^2)'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1/psi0' with respect to 'psi1' as: '1/psi0'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  odds_ratio <- function(psi1, psi0) (psi1*(1-psi0))/(psi0*(1-psi1)) or <- rctglm(formula = Y ~ .,               exposure_indicator = A,               exposure_prob = exp_prob,               data = dat_binom,               family = binomial,               estimand_fun = odds_ratio) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function '(psi1 * (1 - psi0))/(psi0 * (1 - psi1))' with respect to 'psi0' as: '{     .e1 <- 1 - psi1     .e2 <- psi0 * .e1     -(psi1 * ((1 - psi0) * .e1/.e2^2 + 1/.e2)) }'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function '(psi1 * (1 - psi0))/(psi0 * (1 - psi1))' with respect to 'psi1' as: '{     .e2 <- psi0 * (1 - psi1)     (1 - psi0) * (1/.e2 + psi0 * psi1/.e2^2) }'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for objects of class rctglm ‚Äî rctglm_methods","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"Methods mostly extract information model fit inference. See details information method.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"","code":"estimand(object)  # S3 method for class 'rctglm' estimand(object)  est(object)  # S3 method for class 'rctglm' coef(object, ...)  # S3 method for class 'rctglm' print(x, digits = max(3L, getOption(\"digits\") - 3L), ...)"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"object object class rctglm ... additional arguments passed methods x object class rctglm digits numeric number digits display printing","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"estimand/est returns data.frame columns Estimate Std. Error estimate standard error estimand. coef returns named numeric, result glm method coef glm object contained within rctglm object.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"function estimand (short-hand version est) can used extract data.frame estimated value standard error estimand. method generic coef added rctglm (.e., coef.rctglm), uses method coef.glm extract coefficient information underlying glm fit procedure.","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"","code":"# Generate some data to showcase example n <- 100 exposure_prob <- .5 dat_binom <- glm_data(   Y ~ 1+1.5*X1+2*A,   X1 = rnorm(n),   A = rbinom(n, 1, exposure_prob),   family = binomial() )  # Fit the model ate <- rctglm(formula = Y ~ .,               exposure_indicator = A,               exposure_prob = exposure_prob,               data = dat_binom,               family = binomial,               estimand_fun = \"ate\") #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  print(ate) #>  #> Object of class rctglm  #>  #> Call:  rctglm(formula = Y ~ ., exposure_indicator = A, exposure_prob = exposure_prob,  #>     data = dat_binom, family = binomial, estimand_fun = \"ate\") #>  #> Counterfactual control mean (psi_0=E[Y|X, A=0]) estimate: 0.7789 #> Counterfactual control mean (psi_1=E[Y|X, A=1]) estimate: 0.8888 #> Estimand function r: psi1 - psi0 #> Estimand (r(psi_1, psi_0)) estimate (SE): 0.1099 (0.06788) estimand(ate) #>    Estimate Std. Error #> 1 0.1098769 0.06788006 coef(ate) #> (Intercept)          X1           A  #>   1.3909470   1.0711635   0.9680493"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":null,"dir":"Reference","previous_headings":"","what":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"procedure uses fit_best_learner fit prognostic model historical data uses model produce counterfactual predictions prognostic score adjusted covariate rctglm procedure. See Powering RCTs marginal effects GLMs using prognostic score adjustment H√∏jbjerre-Frandsen et. al (2025) details.","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"","code":"rctglm_with_prognosticscore(   formula,   exposure_indicator,   exposure_prob,   data,   family = gaussian,   estimand_fun = \"ate\",   estimand_fun_deriv0 = NULL,   estimand_fun_deriv1 = NULL,   cv_variance = FALSE,   cv_variance_folds = 10,   ...,   data_hist,   prog_formula = NULL,   cv_prog_folds = 5,   learners = default_learners(),   verbose = options::opt(\"verbose\") )"},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"formula object class \"formula\" (one can coerced class): symbolic description model fitted. details model specification given ‚ÄòDetails‚Äô glm documentation. exposure_indicator (name ) binary variable data identifies randomisation groups. variable required binary make \"orientation\" estimand_fun clear. exposure_prob numeric probability \"group 1\" (rather group 0) groups defined exposure_indicator. data optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found data, variables taken environment(formula), typically environment function called. family description error distribution link     function used model.  glm can     character string naming family function, family function     result call family function.  glm.fit     third option supported.  (See family details     family functions.) estimand_fun function arguments psi1 psi0 specifying estimand. Alternative, specify \"ate\" \"rate_ratio\" character use one default estimand functions. See details \"Estimand\" section rctglm. estimand_fun_deriv0 function specifying derivative estimand_fun wrt. psi0. default algorithm use symbolic differentiation automatically find derivative estimand_fun estimand_fun_deriv1 function specifying derivative estimand_fun wrt. psi1. default algorithm use symbolic differentiation automatically find derivative estimand_fun cv_variance logical determining whether estimate variance using cross-validation (see details rctglm). cv_variance_folds numeric number folds use cross validation cv_variance TRUE. ... Additional arguments passed stats::glm() data_hist data.frame historical data fit prognostic model prog_formula object class \"formula\" (one can coerced class): symbolic description prognostic model fitted data_hist. Passed list preproc argument fit_best_learner(). default, formula created modelling response (assumed name formula) using columns data_hist. cv_prog_folds numeric number cross-validation folds used fitting evaluating models learners list (preferably named) containing named lists elements model optionally grid. model element parsnip model specification, passed workflowsets::workflow_set model argument, grid element passed grid argument workflowsets::option_add verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE')","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"rctglm_with_prognosticscore returns object class rctglm_prog, inherits rctglm. rctglm_prog object list components rctglm object (see Value section rctglm breakdown structure), additional list element : prognostic_info: List information fitted prognostic model historical data. components: formula: formula symbolic description response modelled function covariates models model_fit: trained workflow - result fit_best_learner learners: list learners used discrete super learner cv_folds: amount folds used cross validation data: historical data used cross validation fitting testing models","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"Prognostic covariate adjustment involves training prognostic model (using fit_best_learner) historical data (data_hist) predict response data. Assuming historical data representative comparator group ‚Äúnew‚Äù data set (group 0 binary exposure_indicator data), can use prognostic model predict counterfactual outcome observations (including ones comparator group prediction counterfactual outcome coincides prediction actual outcome). prediction, called prognostic score, used adjustment covariate GLM (prognostic score added formula calling rctglm modified formula). See much details reference description.","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"","code":"# Generate some data n <- 100 b0 <- 1 b1 <- 1.5 b2 <- 2 W1 <- runif(n, min = -2, max = 2) exp_prob <- .5  dat_treat <- glm_data(   Y ~ b0+b1*abs(sin(W1))+b2*A,   W1 = W1,   A = rbinom (n, 1, exp_prob) )  dat_notreat <- glm_data(   Y ~ b0+b1*abs(sin(W1)),   W1 = W1 )  learners <- list(   mars = list(     model = parsnip::set_engine(       parsnip::mars(         mode = \"regression\", prod_degree = 3       ),       \"earth\"     )  ),     lm = list(       model = parsnip::set_engine(         parsnip::linear_reg(),         \"lm\"       )     ) ) ate <- rctglm_with_prognosticscore(   formula = Y ~ .,   exposure_indicator = A,   exposure_prob = exp_prob,   data = dat_treat,   family = gaussian(),   estimand_fun = \"ate\",   data_hist = dat_notreat,   learners = learners) #>  #> ‚îÄ‚îÄ Fitting prognostic model ‚îÄ‚îÄ #>  #> ‚Ñπ Created formula for fitting prognostic model as: Y ~ . #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 1 of 2 resampling: mod_mars #> ‚úî 1 of 2 resampling: mod_mars (125ms) #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 2 of 2 resampling: mod_lm #> ‚úî 2 of 2 resampling: mod_lm (96ms) #> ‚Ñπ Model with lowest RMSE: mod_mars #> ‚Ñπ Investigate trained learners and fitted model in `prognostic_info` list element #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  # Pull information on estimand estimand(ate) #>   Estimate Std. Error #> 1 2.043516  0.1911481"},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/news/index.html","id":"postcard-100","dir":"Changelog","previous_headings":"","what":"postcard 1.0.0","title":"postcard 1.0.0","text":"CRAN release: 2025-04-08 Major overhaul package. Still focuses analysing data use prognostic scores, takes general approach allows distribution response covariates within scope generalised linear models (GLMs) necessarily run number data sets created simulation. package provides novel methods : rctglm: Finding marginal effect estimand estimating standard error using influence functions avoid inflation type 1 error rctglm_with_prognosticscore: , leveraging historical data increase precision prognostic scores. Additionally, package includes functionalities fitting discrete super learner fit_best_learner, leveraged rctglm_with_prognosticscore standard methods ANCOVA models (see help topic power_linear) novel method model estimating marginal effects (power_marginaleffect) generating data GLM (glm_data)","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/news/index.html","id":"features-0-2-1","dir":"Changelog","previous_headings":"","what":"Features","title":"postcard 0.2.1","text":"Added function simulate_collection takes function arguments simulate covariates model outcome historical ‚Äúcurrent‚Äù data give user full flexibility (previously multivariate normal distribution assumed) sim.lm simulates data multivariate normal distribution models outcome linear model now wrapper new - general - simulate_collection.","code":""},{"path":[]},{"path":"https://novonordisk-opensource.github.io/postcard/news/index.html","id":"features-0-2-0","dir":"Changelog","previous_headings":"","what":"Features","title":"postcard 0.2.0","text":"Added option use sandwich HC estimators covariance matrix sim.lm Updated default value ATE_shift sim.lm","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/news/index.html","id":"code-cleanup-0-2-0","dir":"Changelog","previous_headings":"","what":"Code cleanup","title":"postcard 0.2.0","text":"Modularised code. Fx. split lm.hist lm.procova lm.psm Renamed functionalities Correcting errors documentation","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/news/index.html","id":"best-practices-package-0-2-0","dir":"Changelog","previous_headings":"","what":"Best practices package","title":"postcard 0.2.0","text":"Updated DESCRIPTION Created README Added explicit package imports form foo::xx Added tests","code":""},{"path":"https://novonordisk-opensource.github.io/postcard/news/index.html","id":"postcard-010","dir":"Changelog","previous_headings":"","what":"postcard 0.1.0","title":"postcard 0.1.0","text":"Initial package created local files. Package contains functionalities create simulation study specific purpose related article. Functionalities include generation collection data sets way analyse data sets assuming special case multivariate normal distribution covariates linear model response. addition, functionalities estimate power certain parameter tests based results.","code":""}]
