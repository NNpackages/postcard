[{"path":"https://nnpackages.github.io/postcard/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 Postcard authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"generating-some-data-to-run-examples","dir":"Articles","previous_headings":"","what":"Generating some data to run examples","title":"Controlling behavior of model fitting functions","text":"vignette(\"postcard\"), simulate data using glm_data() function package.","code":"n <- 1000 b0 <- 1 b1 <- 3 b2 <- 2  dat_gaus <- glm_data(   Y ~ b0+b1*sin(W)^2+b2*A,   W = runif(n, min = -2, max = 2),   A = rbinom(n, 1, prob = 1/2) )  dat_gaus_hist <- glm_data(   Y ~ b0+b1*sin(W)^2,   W = runif(n, min = -2, max = 2) )  dat_pois <- glm_data(   Y ~ b0+b1*sin(W)^2+b2*A,   W = runif(n, min = -2, max = 2),   A = rbinom(n, 1, 1/2),   family = poisson(link = \"log\") )"},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"controlling-verbosity","dir":"Articles","previous_headings":"","what":"Controlling verbosity","title":"Controlling behavior of model fitting functions","text":"See package level options documentation options(), giving information change package behavior options environmental variables. option verbose, controls amount information printed console. default, verbose = 2, meaning various information printed throughout algorithm. Change verbose = 1 little less information verbose = 0 information. showcase information printed different specifications verbosity. Verbosity suppressed rest vignette setting option postcard.verbose 0.","code":"# Default amount of printing ate <- rctglm(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   verbose = 2) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` ate_prog <- rctglm_with_prognosticscore(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   data_hist = dat_gaus_hist,   verbose = 2) #>  #> ‚îÄ‚îÄ Fitting prognostic model ‚îÄ‚îÄ #>  #> ‚Ñπ Created formula for fitting prognostic model as: Y ~ . #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> ‚Ä¢ mod_gbt #> i  No tuning parameters. `fit_resamples()` will be attempted #> i 1 of 3 resampling: mod_mars #> ‚úî 1 of 3 resampling: mod_mars (186ms) #> i  No tuning parameters. `fit_resamples()` will be attempted #> i 2 of 3 resampling: mod_lm #> ‚úî 2 of 3 resampling: mod_lm (92ms) #> i 3 of 3 tuning:     mod_gbt #> ‚úî 3 of 3 tuning:     mod_gbt (1.3s) #> ‚Ñπ Model with lowest RMSE: mod_mars #> ‚Ñπ Investigate trained learners and fitted model in `prognostic_info` list element #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` # At little less printing ate <- rctglm(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   verbose = 1) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` ate_prog <- rctglm_with_prognosticscore(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   data_hist = dat_gaus_hist,   verbose = 1) #>  #> ‚îÄ‚îÄ Fitting prognostic model ‚îÄ‚îÄ #>  #> ‚Ñπ Created formula for fitting prognostic model as: Y ~ . #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> ‚Ä¢ mod_gbt #> ‚Ñπ Model with lowest RMSE: mod_gbt #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` # No printing ate <- rctglm(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   verbose = 0) ate_prog <- rctglm_with_prognosticscore(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   data_hist = dat_gaus_hist,   verbose = 0)"},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"specifying-the-estimand","dir":"Articles","previous_headings":"","what":"Specifying the estimand","title":"Controlling behavior of model fitting functions","text":"default estimand_fun rctglm() rctglm_with_prognosticscore() average treatment effect (ATE). However, ‚Äôs possible specify estimand giving function 2 named arguments, psi0 psi1. Note addition estimand_fun, functions also take arguments estimand_fun_deriv0 estimand_fun_deriv1, derivative respect psi0 psi1, respectively. default, NULL, means symbolic differentiation performed estimand_fun derive automatically. Note verbose > 0, information printed console results symbolic differentiation. run code verbose = 1 though otherwise muted vignette showcase .","code":""},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"built-in-estimands---average-treatment-effect-and-rate-ratio","dir":"Articles","previous_headings":"Specifying the estimand","what":"Built-in estimands - average treatment effect and rate ratio","title":"Controlling behavior of model fitting functions","text":"Built ATE rate ratio, can specified character strings. apparent documentation rctglm() rctglm_with_prognosticscore(), default estimand_fun \"ate\", similarly user can specify estimand_fun = \"rate_ratio\" use estimand function psi1 / psi0 seen :","code":"rate_ratio <- rctglm(   formula = Y ~ A + W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_pois,   family = \"poisson\",   estimand_fun = \"rate_ratio\",   verbose = 1) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1/psi0' with respect to 'psi0' as: '-(psi1/psi0^2)'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1/psi0' with respect to 'psi1' as: '1/psi0'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` rate_ratio$estimand_funs #> $f #> function (psi1, psi0)  #> psi1/psi0 #> <bytecode: 0x55735a095c88> #> <environment: 0x55736a0087d8> #>  #> $d0 #> function (psi1, psi0)  #> -(psi1/psi0^2) #> <environment: 0x55736a0087d8> #>  #> $d1 #> function (psi1, psi0)  #> 1/psi0 #> <environment: 0x55736a0087d8>"},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"specifying-any-estimand","dir":"Articles","previous_headings":"Specifying the estimand","what":"Specifying any estimand","title":"Controlling behavior of model fitting functions","text":"example showing specification custom defined function arguments psi0 psi1.","code":"nonsense_estimand_fun <- function(psi1, psi0) {   psi1 / sqrt(psi0) * 2 - 1 }  nonsense_estimand <- rctglm(   formula = Y ~ A * W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_pois,   family = poisson(),   estimand_fun = nonsense_estimand_fun,   verbose = 1) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function '{     psi1/sqrt(psi0) * 2 - 1 }' with respect to 'psi0' as: '-(psi1/(psi0 * sqrt(psi0)))'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function '{     psi1/sqrt(psi0) * 2 - 1 }' with respect to 'psi1' as: '2/sqrt(psi0)'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1` nonsense_estimand$estimand_funs #> $f #> function (psi1, psi0)  #> { #>     psi1/sqrt(psi0) * 2 - 1 #> } #>  #> $d0 #> function (psi1, psi0)  #> -(psi1/(psi0 * sqrt(psi0))) #>  #> $d1 #> function (psi1, psi0)  #> 2/sqrt(psi0)"},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"variance-estimation-using-cross-validation","dir":"Articles","previous_headings":"","what":"Variance estimation using cross validation","title":"Controlling behavior of model fitting functions","text":"variance estimated variance influence function marginal effect. calculation function, counterfactual predictions made observations, using GLM predict outcome case exposure group 0 1, respectively. cv_variance argument rctglm() rctglm_with_prognosticscore() enables obtaining counterfactual predictions --sample (OOS) prediction using cross validation.","code":""},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"prognostic-covariate-adjustment","dir":"Articles","previous_headings":"","what":"Prognostic covariate adjustment","title":"Controlling behavior of model fitting functions","text":"rctglm_with_prognosticscore() uses function fit_best_learner() fit prognostic model historical data, data_hist. Thereafter, model used predict prognostic scores observations data using scores covariate performing plug-etimation GLM using rctglm. behavior fit_best_learner() subsequently fitting prognostic model data_hist rctglm_with_prognosticscore() fit discrete super learner (discrete avoid overfitting) finding model lowest RMSE among list models. algorithm uses default 5 folds cross validation (cv_prog_folds) formula given prognostic model (prog_formula), function attempts model response name given formula using intercept main effect variables data_hist.","code":""},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"specifying-learners","dir":"Articles","previous_headings":"Prognostic covariate adjustment","what":"Specifying learners","title":"Controlling behavior of model fitting functions","text":"fit_best_learner list default models use fitting discrete super learner, can seen section . However, ‚Äôs easy user specify list learners train discrete super learner. package utilises framework tidymodels, can seen list models can look like.","code":""},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"default-learners","dir":"Articles","previous_headings":"Prognostic covariate adjustment > Specifying learners","what":"Default learners","title":"Controlling behavior of model fitting functions","text":"show code unexported default_learners function, creates list default learners used fit_best_learner() rctglm_with_prognosticscore(). body function thus represents valid way specifying learners argument.","code":"postcard:::default_learners #> function ()  #> { #>     list(mars = list(model = parsnip::mars(mode = \"regression\",  #>         prod_degree = 3) %>% parsnip::set_engine(\"earth\"), grid = NULL),  #>         lm = list(model = parsnip::linear_reg() %>% parsnip::set_engine(\"lm\"),  #>             grid = NULL), gbt = list(model = parsnip::boost_tree(mode = \"regression\",  #>             trees = parsnip::tune(\"trees\"), tree_depth = parsnip::tune(\"tree_depth\"),  #>             learn_rate = 0.1) %>% parsnip::set_engine(\"xgboost\"),  #>             grid = data.frame(trees = seq(from = 25, to = 500,  #>                 by = 25), tree_depth = 3))) #> } #> <bytecode: 0x55735bbd0070> #> <environment: namespace:postcard>"},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"creating-own-list-of-learners","dir":"Articles","previous_headings":"Prognostic covariate adjustment > Specifying learners","what":"Creating own list of learners","title":"Controlling behavior of model fitting functions","text":"listing models available tidymodels website, user can specify list models learners argument. example fitting prognostic model discrete super learner best RMSE among random forest linear support vector machines model.","code":"learners <- list(   rf = list(     model = parsnip::rand_forest(       mode = \"regression\",       trees = 500,       min_n = parsnip::tune(\"min_n\")     ) %>%        parsnip::set_engine(\"ranger\"),     grid = data.frame(       min_n = 1:10     )   ),   svm.linear = list(     model = parsnip::svm_linear(       mode = \"regression\",       cost = parsnip::tune(\"cost\"),       margin = parsnip::tune(\"margin\")) %>%        parsnip::set_engine(\"LiblineaR\"),     grid = data.frame(       cost = 1:5,       margin = seq(0.1, 0.5, 0.1)     )   ) )  model_own_learners <- rctglm_with_prognosticscore(   formula = Y ~ A * W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_gaus,   data_hist = dat_gaus_hist,   learners = learners)"},{"path":"https://nnpackages.github.io/postcard/articles/model-fit.html","id":"inspecting-the-prognostic-model","dir":"Articles","previous_headings":"Prognostic covariate adjustment","what":"Inspecting the prognostic model","title":"Controlling behavior of model fitting functions","text":"‚Äôs possible view information regarding fit prognostic model rctglm_prog class object rctglm_with_prognosticscore() returns looking list element prognostic_info. shorthand way using method prog(). Inside list element elements formula: formula used fitting models fit_best_learner() model_fit: result fit_best_learner() learners: list learners used cv_folds: number folds used cross validation data: data given data_hist, prognostic model fitted upon Note change value data show first rows take much space printing vignette.","code":"prog_info <- prog(model_own_learners) prog_info$data <- head(prog_info$data) prog_info #> $formula #> Y ~ . #> <environment: 0x55736020a060> #>  #> $model_fit #> ‚ïê‚ïê Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Formula #> Model: rand_forest() #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Y ~ . #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Ranger result #>  #> Call: #>  ranger::ranger(x = maybe_data_frame(x), y = y, num.trees = ~500,      min.node.size = min_rows(~10L, x), num.threads = 1, verbose = FALSE,      seed = sample.int(10^5, 1))  #>  #> Type:                             Regression  #> Number of trees:                  500  #> Sample size:                      1000  #> Number of independent variables:  1  #> Mtry:                             1  #> Target node size:                 10  #> Variable importance mode:         none  #> Splitrule:                        variance  #> OOB prediction error (MSE):       1.383821  #> R squared (OOB):                  0.3918115  #>  #> $learners #> $learners$rf #> $learners$rf$model #> Random Forest Model Specification (regression) #>  #> Main Arguments: #>   trees = 500 #>   min_n = parsnip::tune(\"min_n\") #>  #> Computational engine: ranger  #>  #>  #> $learners$rf$grid #>    min_n #> 1      1 #> 2      2 #> 3      3 #> 4      4 #> 5      5 #> 6      6 #> 7      7 #> 8      8 #> 9      9 #> 10    10 #>  #>  #> $learners$svm.linear #> $learners$svm.linear$model #> Linear Support Vector Machine Model Specification (regression) #>  #> Main Arguments: #>   cost = parsnip::tune(\"cost\") #>   margin = parsnip::tune(\"margin\") #>  #> Computational engine: LiblineaR  #>  #>  #> $learners$svm.linear$grid #>   cost margin #> 1    1    0.1 #> 2    2    0.2 #> 3    3    0.3 #> 4    4    0.4 #> 5    5    0.5 #>  #>  #>  #> $cv_folds #> [1] 5 #>  #> $data #>           Y          W #> 1 4.0429142  1.8336410 #> 2 5.1553821  1.8259065 #> 3 4.5318651 -1.0377573 #> 4 4.1458895 -1.5460878 #> 5 2.2437462  0.3011256 #> 6 0.5276273  0.5514324"},{"path":"https://nnpackages.github.io/postcard/articles/postcard.html","id":"plug-in-estimation-of-marginal-effects-and-variance-estimation-using-influence-functions","dir":"Articles","previous_headings":"","what":"Plug-in estimation of marginal effects and variance estimation using influence functions","title":"Introduction to postcard","text":"use plug-estimation influence functions can help us obtain accurate estimates. Coupled prognostic covariate adjustment, can increase precision estimates obtain higher power sacrificing control type error rate. Introductory examples use rctglm() rctglm_with_prognosticscore() functions available . details, see vignette(\"model-fit\").","code":""},{"path":"https://nnpackages.github.io/postcard/articles/postcard.html","id":"simulating-data-for-exploratory-analyses","dir":"Articles","previous_headings":"Plug-in estimation of marginal effects and variance estimation using influence functions","what":"Simulating data for exploratory analyses","title":"Introduction to postcard","text":"First, simulate data able enable showcasing functionalities. use glm_data() function package, user can specify expression alongside variables family response simulate response GLM linear predictor given expression provided.","code":"n <- 1000 b0 <- 1 b1 <- 3 b2 <- 2  # Simulate data with a non-linear effect dat_treat <- glm_data(   Y ~ b0+b1*sin(W)^2+b2*A,   W = runif(n, min = -2, max = 2),   A = rbinom(n, 1, prob = 1/2),   family = gaussian() # Default value )"},{"path":"https://nnpackages.github.io/postcard/articles/postcard.html","id":"fitting-rctglm-without-prognostic-covariate-adjustment","dir":"Articles","previous_headings":"Plug-in estimation of marginal effects and variance estimation using influence functions","what":"Fitting rctglm() without prognostic covariate adjustment","title":"Introduction to postcard","text":"rctglm() function estimates specified estimand using plug-estimation randomised clinical trials estimates variance using influence function marginal effect estimand. interface rctglm() similar stats::glm() function added mandatory specification randomisation variable data, usually (name ) treatment variable default, ratio 1‚Äôs data used default, function takes average treatment effect (ATE) estimand Thus, can estimate ATE simply writing : Note default, verbose = 2, meaning information algorithm printed console. However, suppress behavior. See vignette(\"model-fit\"). creates rctglm object prints structure rctglm object broken Value section documentation rctglm(). Methods available estimand (shorthand est) prints data.frame estimate estimand standard error. method coef also available extract coefficients underlying glm fit. See info documentation page rctglm_methods().","code":"ate <- rctglm(formula = Y ~ A * W,               exposure_indicator = A,               exposure_prob = 1/2,               data = dat_treat,               family = \"gaussian\") # Default value ate #>  #> Object of class rctglm  #>  #> Call:  rctglm(formula = Y ~ A * W, exposure_indicator = A, exposure_prob = 1/2,  #>     data = dat_treat, family = \"gaussian\") #>  #> Counterfactual control mean (psi_0=E[Y|X, A=0]) estimate: 2.776 #> Counterfactual control mean (psi_1=E[Y|X, A=1]) estimate: 4.867 #> Estimand function r: psi1 - psi0 #> Estimand (r(psi_1, psi_0)) estimate (SE): 2.091 (0.09209) est(ate) #>   Estimate Std. Error #> 1 2.091095 0.09209306"},{"path":"https://nnpackages.github.io/postcard/articles/postcard.html","id":"using-prognostic-covariate-adjustment","dir":"Articles","previous_headings":"Plug-in estimation of marginal effects and variance estimation using influence functions","what":"Using prognostic covariate adjustment","title":"Introduction to postcard","text":"rctglm_with_prognosticscore() function uses fit_best_learner() function fit prognostic model historical data uses prognostic model predict ùîº[Y|X,=0]\\begin{align} \\mathbb{E}[Y|X,=0] \\end{align} observations current data set. prognostic scores used covariate GLM running rctglm(). Allowing use complex non-linear models create prognostic score allows utilising information potentially many variables, ‚Äúcatching‚Äù non-linear relationships using information GLM model using single covariate adjustment. simulate historical data showcase use function well: call rctglm_with_prognosticscore() rctglm() added specification (Historical) data fit prognostic model using fit_best_learner() Default uses covariates data. (Optionally) number folds cross validation list learners fitting best learner Thus, simple call estimates average treatment effect, adjusting prognostic score, seen : Quick results fit can seen printing object: ‚Äôs evident case non-linear relationship covariate observe response, adjusting prognostic score reduces standard error estimand approximation quite bit.","code":"dat_notreat <- glm_data(   Y ~ b0+b1*sin(W)^2,   W = runif(n, min = -2, max = 2),   family = gaussian # Default value ) ate_prog <- rctglm_with_prognosticscore(   formula = Y ~ A * W,   exposure_indicator = A,   exposure_prob = 1/2,   data = dat_treat,   family = gaussian(link = \"identity\"), # Default value   data_hist = dat_notreat) ate_prog #>  #> Object of class rctglm_prog  #>  #> Call:  rctglm_with_prognosticscore(formula = Y ~ A * W, exposure_indicator = A,  #>     exposure_prob = 1/2, data = dat_treat, family = gaussian(link = \"identity\"),  #>     data_hist = dat_notreat) #>  #> Counterfactual control mean (psi_0=E[Y|X, A=0]) estimate: 2.827 #> Counterfactual control mean (psi_1=E[Y|X, A=1]) estimate: 4.821 #> Estimand function r: psi1 - psi0 #> Estimand (r(psi_1, psi_0)) estimate (SE): 1.994 (0.06405)"},{"path":"https://nnpackages.github.io/postcard/articles/postcard.html","id":"investigating-the-prognostic-model","dir":"Articles","previous_headings":"Plug-in estimation of marginal effects and variance estimation using influence functions > Using prognostic covariate adjustment","what":"Investigating the prognostic model","title":"Introduction to postcard","text":"Information prognostic model available list element prognostic_info, method prog() can used extract. breakdown list includes, see Value section rctglm_with_prognosticscore() documentation.","code":""},{"path":"https://nnpackages.github.io/postcard/articles/postcard.html","id":"power-approximation-in-linear-models","dir":"Articles","previous_headings":"","what":"Power approximation in linear models","title":"Introduction to postcard","text":"cases seeking conduct new studies, sample size/power analyses vital successful planning studies. , present implementations package take advantage power approximation formulas perform analyses. See detailed walkthrough use case vignette(\"prospective-power\"), power curves drawn compared standard ANCOVA model one utilising prognostic covariate adjustment.","code":""},{"path":"https://nnpackages.github.io/postcard/articles/postcard.html","id":"estimating-the-assumed-variance","dir":"Articles","previous_headings":"Power approximation in linear models","what":"Estimating the assumed variance","title":"Introduction to postcard","text":"Finding assumed variance use power analysis ANCOVA model can done using variance_ancova function, estimates term œÉ2(1‚àíR2)\\sigma^2(1-R^2) given formula data.","code":"vanc <- variance_ancova(Y ~ A + W, data = dat_treat) vanc #> [1] 2.120278"},{"path":"https://nnpackages.github.io/postcard/articles/postcard.html","id":"finding-the-power-or-sample-size","dir":"Articles","previous_headings":"Power approximation in linear models","what":"Finding the power (or sample size)","title":"Introduction to postcard","text":"Functions power_gs() power_nc() exist, estimate power given sample size n using approximation formulas. functions results two different approximation formulas behave exactly except mandatory specification df argument power_nc function, gives degrees freedom t-distribution used. Details formulas available documentation Guenther-Schouten approximation, formula directly gives us sample size function power, getting required sample size function power available function samplesize_gs().","code":"power_gs(variance = vanc, n = 100, ate = 0.8) #> [1] 0.7765394 power_nc(variance = vanc, n = 100, df = 97, ate = 0.8) #> [1] 0.7763057 samplesize_gs(variance = vanc, ate = 0.8, power = 0.9) #> [1] 141.1623"},{"path":"https://nnpackages.github.io/postcard/articles/prospective-power.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Prospective Power Estimation","text":"described , data available time prospective power analysis. showcase common use case, simulate historical data, use estimate variance response adjusted coefficient determination function variance_ancova(). compare power curves ‚Äústandard‚Äù ANCOVA model one using prognostic covariate adjustment, simulate historical data, can fit prognostic model training data use resulting model predict prognostic scores test data.","code":"# Generate some data n_train <- 2000 n_test <- 200 b0 <- 1 b1 <- 1.6 b2 <- 1.4 b3 <- 2 b4 <- 0.8  data_train <- glm_data(   Y ~ b0+b1*abs(sin(X1))+b2*X2+b3*X3+b4*X2*X3,   X1 = runif(n_train, min = -2, max = 2),   X2 = rnorm(n_train, mean = 2, sd = 2),   X3 = rbinom(n_train, 1, 0.5) )  data_test <- glm_data(   Y ~ b0+b1*abs(sin(X1))+b2*X2+b3*X3+b4*X2*X3,   X1 = runif(n_test, min = -2, max = 2),   X2 = rnorm(n_test, mean = 2, sd = 2),   X3 = rbinom(n_test, 1, 0.5) )"},{"path":"https://nnpackages.github.io/postcard/articles/prospective-power.html","id":"fitting-a-prognostic-model","dir":"Articles","previous_headings":"","what":"Fitting a prognostic model","title":"Prospective Power Estimation","text":"Using training part historical data, fit prognostic model using fit_best_learner() function. fits discrete super learner returns trained workflow, can use prediction construct prognostic scores.","code":"lrnr <- fit_best_learner(   data = data_train,   formula = Y ~ .,   cv_folds = 10,   verbose = 0 )  data_test <- dplyr::bind_cols(data_test, predict(lrnr, data_test))"},{"path":"https://nnpackages.github.io/postcard/articles/prospective-power.html","id":"estimating-the-variance-used-for-power-approximation","dir":"Articles","previous_headings":"","what":"Estimating the variance used for power approximation","title":"Prospective Power Estimation","text":"use function variance_ancova estimate entity œÉ2(1‚àíR2)\\sigma^2(1-R^2) case ‚Äústandard‚Äù ANCOVA model adjusting covariates data, case ANCOVA utilising prognostic covariate adjustment adjusting prognostic score covariate.","code":"var_bound_ancova <- variance_ancova(Y ~ X1 + X2 + X3, data = data_test) var_bound_prog <- variance_ancova(Y ~ X1 + X2 + X3 + .pred, data = data_test)"},{"path":"https://nnpackages.github.io/postcard/articles/prospective-power.html","id":"creating-a-plot-of-power-curves","dir":"Articles","previous_headings":"","what":"Creating a plot of power curves","title":"Prospective Power Estimation","text":"order see estimated power behaves function total sample size, iterate power_gs function number different sample sizes save results using estimated variance without prognostic covariate adjustment. Note just use power_gs() function, power_nc() also available works exactly except needs additional mandatory argument df degrees freedom t-distribution. create plot estimated power across values sample sizes two different models, mark desired power 90% horizontal line create vertical lines labels show sample size needed obtain 90% power model. Note just interested finding sample size needed 90% power, simply running samplesize_gs() enough.","code":"desired_power <- 0.9 n_from <- 10 n_to <- 250  iterate_power <- function(variance) {   power_ancova <- sapply(n_from:n_to, FUN = function(n) power_gs(     n = n,     variance = variance,     r = 1, ate = .8, margin = 0   )   )   data.frame(n = n_from:n_to, power = power_ancova) }  data_power <- dplyr::bind_rows(   iterate_power(var_bound_ancova) %>%      dplyr::mutate(       n_desired = samplesize_gs(         variance = var_bound_ancova,         power = desired_power,         r = 1, ate = .8, margin = 0       ),       model = \"ancova\",       model_label = \"ANCOVA\"     ),   iterate_power(var_bound_prog) %>%      dplyr::mutate(       n_desired = samplesize_gs(         variance = var_bound_prog,         power = desired_power,         r = 1, ate = .8, margin = 0       ),       model = \"prog\",       model_label = \"ANCOVA with prognostic score\") ) model_cols <- c(ancova = \"darkorange1\", prog = \"dodgerblue4\")  show_npower <- function(data, coords) {   line <- grid::segmentsGrob(     x0 = coords$x, x1 = coords$x,     y0 = 0, y1 = coords$y,     gp = grid::gpar(       lty = \"dashed\",       col = data$colour     ))   group <- unique(data$group)   if (group == 1)      y_pos <- grid::unit(coords$y, \"npc\") - grid::unit(2, \"mm\")   else      y_pos <- grid::unit(0.55, \"npc\")   label <- grid::textGrob(     label = paste0(data$model_label, \": \", ceiling(data$x)),     x = grid::unit(coords$x, \"npc\") + grid::unit(2, \"mm\"),     y = y_pos,     just = c(0, 1),     gp = grid::gpar(col = data$colour)   )   grid::grobTree(line, label) }  data_power %>%   ggplot2::ggplot(ggplot2::aes(x = n, y = power, color = model)) +   ggplot2::geom_line(linewidth = 1.2, alpha = 0.8,                      show.legend = FALSE) +   ggplot2::geom_hline(     yintercept = desired_power,     color = \"grey40\",     linetype = \"dashed\"   ) +   gggrid::grid_group(     show_npower,     ggplot2::aes(x = n_desired,                  y = desired_power,                  model_label = model_label)   ) +   ggplot2::scale_color_manual(     name = \"\",     values = model_cols) +   ggplot2::scale_y_continuous(     breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1),     labels = function(x) paste0(x*100, \"%\")   ) +   ggplot2::labs(x = \"Total sample size\", y = \"Power\",                 title = \"Guenther Schouten approximation of power\") +   ggplot2::theme(plot.title = ggplot2::element_text(     face = \"bold\",     size = 16   )) +   ggplot2::theme_minimal()"},{"path":"https://nnpackages.github.io/postcard/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mathias Lerbech Jeppesen. Author, maintainer. Emilie Hojbjerre-Frandsen. Author.","code":""},{"path":"https://nnpackages.github.io/postcard/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jeppesen M, Hojbjerre-Frandsen E (2025). postcard: Estimation Marginal Effects Using Prognostic Covariate Adjustment. R package version 0.2.1.9000, https://nnpackages.github.io/postcard/.","code":"@Manual{,   title = {postcard: Estimation of Marginal Effects Using Prognostic Covariate Adjustment},   author = {Mathias Lerbech Jeppesen and Emilie Hojbjerre-Frandsen},   year = {2025},   note = {R package version 0.2.1.9000},   url = {https://nnpackages.github.io/postcard/}, }"},{"path":"https://nnpackages.github.io/postcard/index.html","id":"postcard","dir":"","previous_headings":"","what":"Estimation of Marginal Effects Using Prognostic Covariate Adjustment","title":"Estimation of Marginal Effects Using Prognostic Covariate Adjustment","text":"postcard provides tools accurately estimating marginal effects using plug-estimation GLMs, including increasing precision using prognostic covariate adjustment.","code":""},{"path":"https://nnpackages.github.io/postcard/index.html","id":"estimating-marginal-effects","dir":"","previous_headings":"","what":"Estimating marginal effects","title":"Estimation of Marginal Effects Using Prognostic Covariate Adjustment","text":"rctglm() used estimate marginal effects. See introductory examples usage vignette(\"postcard\") details vignette(\"model-fit\"). Marginal effects causal effects form r(Œ®1,Œ®0)r(\\Psi_1, \\Psi_0), Œ®a=ùîº[Y()]\\Psi_a=\\mathbb{E}[Y()] population mean outcomes exposure =0,1a=0, 1, respectively. sometimes referred counterfactual means. package uses plug-estimation robust estimation marginal effect estimand well influence functions robust estimation variance estimand (Rosenblum, M. M. J. van der Laan, 2010: Simple, efficient estimators treatment effects randomized trials using generalized linear models leverage baseline variables. International Journal Biostatistics, 6, . 1).","code":""},{"path":"https://nnpackages.github.io/postcard/index.html","id":"prognostic-covariate-adjustment","dir":"","previous_headings":"","what":"Prognostic covariate adjustment","title":"Estimation of Marginal Effects Using Prognostic Covariate Adjustment","text":"rctglm_with_prognosticscore() used estimate marginal effects including use prognostic covariate adjustment. See introductory examples usage vignette(\"postcard\") details vignette(\"model-fit\"). Prognostic covariate adjustment involves training prognostic model historical data predict response data. Assuming historical data representative comparator group ‚Äúnew‚Äù data set, can use prognostic model predict comparator counterfactual outcome observations (including ones comparator group). prediction, called prognostic score used adjustment covariate GLM.","code":""},{"path":"https://nnpackages.github.io/postcard/index.html","id":"power-approximation-for-linear-models","dir":"","previous_headings":"","what":"Power approximation for linear models","title":"Estimation of Marginal Effects Using Prognostic Covariate Adjustment","text":"Additionally, implementations sample size/power approximation formulas available, enabling retrospective power analyses performed using package. Functionalities available help page powerss(), introductory examples vignette(\"postcard\") details vignette(\"prospective-power\").","code":""},{"path":"https://nnpackages.github.io/postcard/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimation of Marginal Effects Using Prognostic Covariate Adjustment","text":"can install development version postcard GitHub :","code":"pak::pak(\"NNpackages/postcard\")"},{"path":"https://nnpackages.github.io/postcard/reference/fit_best_learner.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"Find best learner terms RMSE among specified learners using cross validation","code":""},{"path":"https://nnpackages.github.io/postcard/reference/fit_best_learner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"","code":"fit_best_learner(   data,   formula,   cv_folds = 5,   learners = default_learners(),   verbose = options::opt(\"verbose\") )"},{"path":"https://nnpackages.github.io/postcard/reference/fit_best_learner.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"data optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found data, variables taken environment(formula), typically environment function called. formula object class \"formula\" (one can coerced class): symbolic description model fitted. details model specification given ‚ÄòDetails‚Äô glm documentation. cv_folds numeric number cross-validation folds used fitting evaluating models learners list tidymodels verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE')","code":""},{"path":"https://nnpackages.github.io/postcard/reference/fit_best_learner.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"trained workflow","code":""},{"path":"https://nnpackages.github.io/postcard/reference/fit_best_learner.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"Ensure data compatibility learners.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/fit_best_learner.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the best learner in terms of RMSE among specified learners using cross validation ‚Äî fit_best_learner","text":"","code":"# Generate some synthetic 2-armed RCT data along with historical controls n <- 100 dat_rct <- glm_data(   Y ~ 1+2*x1+3*a,   x1 = rnorm(n, 2),   a = rbinom (n, 1, .5),   family = gaussian() ) dat_hist <- glm_data(   Y ~ 1+2*x1,   x1 = rnorm(n, 2),   family = gaussian() )  # Fit a learner to the historical control data with default learners fit <- fit_best_learner(Y ~ ., data = dat_hist) #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> ‚Ä¢ mod_gbt #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 1 of 3 resampling: mod_mars #> ‚úî 1 of 3 resampling: mod_mars (188ms) #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 2 of 3 resampling: mod_lm #> ‚úî 2 of 3 resampling: mod_lm (95ms) #> i 3 of 3 tuning:     mod_gbt #> ‚úî 3 of 3 tuning:     mod_gbt (933ms) #> ‚Ñπ Model with lowest RMSE: mod_lm  # Use it fx. to predict the \"control outcome\" in the 2-armed RCT predict(fit, new_data = dat_rct) #> # A tibble: 100 √ó 1 #>    .pred #>    <dbl> #>  1 2.25  #>  2 5.50  #>  3 0.217 #>  4 4.99  #>  5 6.22  #>  6 7.25  #>  7 1.42  #>  8 4.51  #>  9 4.52  #> 10 4.44  #> # ‚Ñπ 90 more rows"},{"path":"https://nnpackages.github.io/postcard/reference/glm_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate data simulated from a GLM ‚Äî glm_data","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"Provide formula, variables family generate linear predictor using formula provided variables using inverse link family generate GLM modelled mean, mu, used simulate response mean generating function according chosen family.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/glm_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"","code":"glm_data(formula, ..., family = gaussian(), family_args = list(sd = 1))"},{"path":"https://nnpackages.github.io/postcard/reference/glm_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"formula object class \"formula\" (one can coerced class): symbolic description model fitted. details model specification given ‚ÄòDetails‚Äô glm documentation. ... data.frame columns corresponding variables used formula, named list variables, individually provided named arguments variables family family response. can character string naming family function, family function result call family function family_args named list values arguments passed family relevant r<family_name> function simulating data","code":""},{"path":"https://nnpackages.github.io/postcard/reference/glm_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"data.frame","code":""},{"path":"https://nnpackages.github.io/postcard/reference/glm_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate data simulated from a GLM ‚Äî glm_data","text":"","code":"# Generate a gaussian response from a single covariate glm_data(Y ~ 1+2*x1,                 x1 = rnorm(10)) #>            Y          x1 #> 1  -1.449147 -0.89480241 #> 2   2.865960  0.90426912 #> 3  -1.648712  0.07964921 #> 4  -2.429914 -1.25882722 #> 5   2.268991  1.02568511 #> 6  -1.125662 -0.73077860 #> 7   1.246019 -0.19014551 #> 8   1.550481  0.52886469 #> 9   2.370782  0.55021053 #> 10  2.566846  0.54968434  # Generate a gaussian response from a single covariate with non-linear # effects. Specify that the response should have standard deviation sqrt(3) glm_data(Y ~ 1+2*abs(sin(x1)),                 x1 = runif(10, min = -2, max = 2),                 family_args = list(sd = sqrt(3))) #>            Y         x1 #> 1  5.8875239  1.0618623 #> 2  1.8274380  0.5078665 #> 3  4.9617796  0.9213538 #> 4  0.5141856 -0.3051824 #> 5  2.2240450 -0.9266769 #> 6  1.5760863  1.0761921 #> 7  0.9143955  0.3493867 #> 8  4.0499201  1.5942710 #> 9  4.0731122  1.4812982 #> 10 0.5794237 -0.4027751  # Generate a negative binomial response glm_data(Y ~ 1+2*x1-x2,                 x1 = rnorm(10),                 x2 = rgamma(10, shape = 2),                 family = MASS::negative.binomial(2)) #>     Y         x1        x2 #> 1   0 -0.7836391 2.3050987 #> 2   1 -0.9531239 1.3214499 #> 3   0  1.7927561 3.7469426 #> 4   0  0.3489767 1.8461783 #> 5   2  0.2591038 2.0354566 #> 6   0 -0.8059519 0.6438993 #> 7   4  0.1056647 0.7646888 #> 8   2 -0.3335997 0.9691220 #> 9  20  1.6418480 0.6479179 #> 10  0 -0.6439059 0.5980742  # Provide variables as a list/data.frame glm_data(resp ~ 1+2*x1-x2,                 data.frame(                   x1 = rnorm(10),                   x2 = rgamma(10, shape = 2)                 ),                 family = MASS::negative.binomial(2)) #>    resp          x1        x2 #> 1     0 -0.05367151 2.0555178 #> 2     0 -0.56352463 4.8979183 #> 3     0 -0.74390896 0.9440099 #> 4     0 -0.10904165 0.3404743 #> 5     0 -0.56082923 2.1408569 #> 6     0  0.18800155 0.6841673 #> 7     1  0.74885094 1.8483538 #> 8     0 -1.91653832 0.6336780 #> 9     2  0.23609585 0.2305099 #> 10    2  0.62895342 1.4685068"},{"path":"https://nnpackages.github.io/postcard/reference/options.html","id":null,"dir":"Reference","previous_headings":"","what":"postcard Options ‚Äî options","title":"postcard Options ‚Äî options","text":"Internally used, package-specific options. options prioritize R options() values, fall back environment variables undefined. neither option environment variable set, default value used.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"postcard Options ‚Äî options","text":"verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE')","code":""},{"path":"https://nnpackages.github.io/postcard/reference/options.html","id":"checking-option-values","dir":"Reference","previous_headings":"","what":"Checking Option Values","title":"postcard Options ‚Äî options","text":"Option values specific postcard can accessed passing package name env.","code":"options::opts(env = \"postcard\")  options::opt(x, default, env = \"postcard\")"},{"path":"https://nnpackages.github.io/postcard/reference/options.html","id":"options","dir":"Reference","previous_headings":"","what":"Options","title":"postcard Options ‚Äî options","text":"verbose default: 2 option: postcard.verbose envvar: R_POSTCARD_VERBOSE (evaluated possible, raw string otherwise)","code":"2"},{"path":[]},{"path":"https://nnpackages.github.io/postcard/reference/postcard-package.html","id":null,"dir":"Reference","previous_headings":"","what":"postcard: Estimation of Marginal Effects Using Prognostic Covariate Adjustment ‚Äî postcard-package","title":"postcard: Estimation of Marginal Effects Using Prognostic Covariate Adjustment ‚Äî postcard-package","text":"Conducting analysis using robust plug-GLM estimation influence functions prognostic covariate adjustment.","code":""},{"path":[]},{"path":"https://nnpackages.github.io/postcard/reference/postcard-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"postcard: Estimation of Marginal Effects Using Prognostic Covariate Adjustment ‚Äî postcard-package","text":"Maintainer: Mathias Lerbech Jeppesen mathiasljeppesen@outlook.com Authors: Emilie Hojbjerre-Frandsen ehfd@novonordisk.com","code":""},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":null,"dir":"Reference","previous_headings":"","what":"Power and sample size estimation for linear models ‚Äî powerss","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"variance_ancova provides convenient function estimating variance use power sample size approximation. power_gs samplesize_gs functions calculate Guenther-Schouten power approximation ANOVA ANCOVA. approximation based (Guenther WC. Sample Size Formulas Normal Theory T Tests. American Statistician. 1981;35(4):243‚Äì244) (Schouten HJA. Sample size formula continuous outcome unequal group sizes unequal variances. Statistics Medicine. 1999;18(1):87‚Äì91). function power_nc calculates power ANOVA ANCOVA based non-centrality parameter exact t-distributions. See details funtion Details sections Value.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"","code":"variance_ancova(formula, data, inflation = 1, deflation = 1)  power_gs(variance, ate, n, r = 1, margin = 0, alpha = 0.025)  samplesize_gs(variance, ate, r = 1, margin = 0, power = 0.9, alpha = 0.025)  power_nc(variance, df, ate, n, r = 1, margin = 0, alpha = 0.025)"},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"formula object class \"formula\" (one can coerced class): symbolic description used stats::model.frame() create data.frame response covariates. data.frame used estimate \\(R^2\\), used find variance. See details. data data frame, list environment (object     coercible .data.frame data frame),     containing variables formula.  Neither matrix     array accepted. inflation numeric multiply marginal variance response . Default 1 estimates variance directly data. Use values 1 obtain conservative estimate marginal response variance. deflation numeric multiply \\(R^2\\) . Default 1 means estimate \\(R^2\\) unchanged. Use values 1 obtain conservative estimate coefficient determination. See details \\(R^2\\) related estimation. variance numeric variance use approximation. See details documentation sections power approximating function. ate numeric minimum effect size able detect. n numeric number participants total. number participants treatment group \\(n1=(r/(1+r))n\\) control group \\(n1=(1/(1+r))n\\). r numeric allocation ratio \\(r=n1/n0\\). one--one randomisation r=1. margin numeric superiority margin (non-inferiority margin, negative value can provided). alpha numeric significance level. Due regulatory guidelines using one-sided test, half specified significance level used. Thus, standard significance level 5%, default alpha = 0.025. power numeric giving desired power calculating sample size df numeric degrees freedom use t-distribution.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"functions return numeric. variance_ancova returns numeric variance estimated data used power estimation sample size estimation. power_xx samplesize_xx functions return numeric power sample size approximation.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"details section provides information relation arguments functions formulas described sections power approximation formula. Note entities carry name argument formula mentioned , obviously linked (n, r, alpha) ate: \\(\\beta_1-\\beta_0\\) margin: \\(\\Delta_s\\) variance: \\(\\widehat{\\sigma}^2(1-\\widehat{R}^2)\\)","code":""},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":"finding-the-variance-to-use-for-approximation","dir":"Reference","previous_headings":"","what":"Finding the variance to use for approximation","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"variance_ancova function estimates \\(\\sigma^2(1-R^2)\\) data returns numeric can passed directly variance power_gs. Corresponds estimating power using lm formula specified variance_ancova. user can estimate variance way see fit.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":"guenther-schouten-power-approximation","dir":"Reference","previous_headings":"","what":"Guenther-Schouten power approximation","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"estimation formula case ANCOVA model multiple covariate adjustement (see description reference): $$ n=\\frac{(1+r)^2}{r}\\frac{(z_{1-\\alpha}+z_{1-\\beta})^2\\widehat{\\sigma}^2(1-\\widehat{R}^2)}{(\\beta_1-\\beta_0-\\Delta_s)^2}+\\frac{(z_{1-\\alpha})^2}{2} $$ \\(\\widehat{R}^2\\coloneqq \\frac{\\widehat{\\sigma}_{XY}^\\top \\widehat{\\Sigma}_X^{-1}\\widehat{\\sigma}_{XY}}{\\widehat{\\sigma}^2}\\), denote \\(\\widehat{\\sigma^2}\\) estimate variance outcome, \\(\\widehat{\\Sigma_X}\\) estimate covariance matrix covariates, \\(\\widehat{\\sigma_{XY}}\\) \\(p\\)-dimensional column vector consisting estimate covariance outcome variable covariate. univariate case \\(R^2\\) replaced \\(\\rho^2\\)","code":""},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":"power-approximation-using-non-centrality-parameter","dir":"Reference","previous_headings":"","what":"Power approximation using non-centrality parameter","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"prospective power estimations based (Kieser M. Methods Applications Sample Size Calculation Recalculation Clinical Trials. Springer; 2020). ANOVA power calculated based non-centrality parameter given $$nc =\\sqrt{\\frac{r}{(1+r)^2}\\cdot n}\\cdot\\frac{\\beta_1-\\beta_0-\\Delta_s}{\\sigma},$$ denote \\(\\sigma^2\\) variance outcome, power can estimated $$1-\\beta = 1 - F_{t,n-2,nc}\\left(F_{t, n-2, 0}^{-1}(1-\\alpha)\\right).$$ power ANCOVA univariate covariate adjustment interaction calculated based non-centrality parameter given $$nc =\\sqrt{\\frac{rn}{(1+r)^2}}\\frac{\\beta_1-\\beta_0-\\Delta_s}{\\sigma\\sqrt{1-\\rho^2}},$$ power can estimated $$1-\\beta = 1 - F_{t,n-3,nc}\\left(F_{t, n-3, 0}^{-1}(1-\\alpha)\\right).$$ power ANCOVA either univariate covariate adjustment interaction multiple covariate adjustement without interaction calculated based non-centrality parameter given $$nc =\\frac{\\beta_1-\\beta_0-\\Delta_s}{\\sqrt{\\left(\\frac{1}{n_1}+\\frac{1}{n_0} + X_d^\\top\\left((n-2)\\Sigma_X\\right)^{-1}X_d \\right)\\sigma^2\\left(1-\\widehat{R}^2\\right)}}.$$ \\(X_d \\coloneqq \\left(\\overline{X}_1^1-\\overline{X}_0^1, \\ldots, \\overline{X}_1^p-\\overline{X}_0^p\\right)^\\top\\), \\(\\widehat{R}^2\\coloneqq \\frac{\\widehat{\\sigma}_{XY}^\\top \\widehat{\\Sigma}_X^{-1}\\widehat{\\sigma}_{XY}}{\\widehat{\\sigma}^2}\\), denote \\(\\widehat{\\sigma^2}\\) estimate variance outcome, \\(\\widehat{\\Sigma_X}\\) estimate covariance matrix covariates, \\(\\widehat{\\sigma_{XY}}\\) \\(p\\)-dimensional column vector consisting estimate covariance outcome variable covariate. Since case randomized trials expected difference covariate values groups 0. Furthermore, elements \\(\\Sigma_X^{-1}\\) small, unless variances close 0, covariates exhibit strong linear dependencies, correlations close 1. scenarios excluded since lead potentially serious problems regarding inference either way. arguments used Zimmermann et. al (Zimmermann G, Kieser M, Bathke AC. Sample Size Calculation Blinded Recalculation Analysis Covariance Models Multiple Random Covariates. Journal Biopharmaceutical Statistics. 2020;30(1):143‚Äì159.) approximate non-centrality parameter univariate case \\(\\rho^2\\) replaced \\(R^2\\). power ANCOVA d degrees freedom can estimated $$1-\\beta = 1 - F_{t,d,nc}\\left(F_{t, d,0), 0}^{-1}(1-\\alpha)\\right).$$","code":""},{"path":"https://nnpackages.github.io/postcard/reference/powerss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power and sample size estimation for linear models ‚Äî powerss","text":"","code":"# Generate a data set to use as an example dat_gaus <- glm_data(Y ~ 1+2*X1-X2+3*A,                 X1 = rnorm(100),                 X2 = rgamma(100, shape = 2),                 A = rbinom(100, size = 1, prob = 0.5),                 family = gaussian())  # Approximate the power using no adjustment covariates va_nocov <- var(dat_gaus$Y) power_gs(n = 200, variance = va_nocov, ate = 1) #> [1] 0.6059117  # Approximate the power with a model adjusting for both variables in the # data generating process  ## First estimate the variance sigma^2 * (1-R^2) va_cov <- variance_ancova(Y ~ X1 + X2 + A, dat_gaus) ## Then estimate the power using this variance power_gs(n = 100, variance = va_cov, ate = 1.8, margin = 1, r = 2) #> [1] 0.9592429  # Approximate the sample size needed to obtain 90% power with same model as # above samplesize_gs(   variance = va_cov, ate = 1.8, power = 0.9, margin = 1, r = 2 ) #> [1] 77.12053  # No adjustment covariates power_nc(n = 200, variance = va_nocov, df = 199, ate = 1) #> [1] 0.6058972 # Adjusting for all covariates in data generating process power_nc(n = 200, variance = va_cov, df = 196, ate = 1.8, margin = 1, r = 2) #> [1] 0.9995171"},{"path":"https://nnpackages.github.io/postcard/reference/prog.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract information about the fitted prognostic model ‚Äî prog","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"Extracts prognostic_info list element rctglm_prog object. See 'Value' rctglm_with_prognosticscore details.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/prog.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"","code":"prog(x)  # S3 method for class 'rctglm_prog' prog(x)"},{"path":"https://nnpackages.github.io/postcard/reference/prog.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"x object class rctglm_prog (returned rctglm_with_prognosticscore)","code":""},{"path":"https://nnpackages.github.io/postcard/reference/prog.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"description","code":""},{"path":"https://nnpackages.github.io/postcard/reference/prog.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract information about the fitted prognostic model ‚Äî prog","text":"","code":"# Generate some data n <- 100 b0 <- 1 b1 <- 1.5 b2 <- 2 W1 <- runif(n, min = -2, max = 2) exposure_prob <- .5  dat_treat <- glm_data(   Y ~ b0+b1*abs(sin(W1))+b2*A,   W1 = W1,   A = rbinom(n, 1, exposure_prob) )  dat_notreat <- glm_data(   Y ~ b0+b1*abs(sin(W1)),   W1 = W1 )  ate <- rctglm_with_prognosticscore(   formula = Y ~ .,   exposure_indicator = A,   exposure_prob = exposure_prob,   data = dat_treat,   family = gaussian(),   estimand_fun = \"ate\",   data_hist = dat_notreat) #>  #> ‚îÄ‚îÄ Fitting prognostic model ‚îÄ‚îÄ #>  #> ‚Ñπ Created formula for fitting prognostic model as: Y ~ . #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> ‚Ä¢ mod_gbt #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 1 of 3 resampling: mod_mars #> ‚úî 1 of 3 resampling: mod_mars (121ms) #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 2 of 3 resampling: mod_lm #> ‚úî 2 of 3 resampling: mod_lm (91ms) #> i 3 of 3 tuning:     mod_gbt #> ‚úî 3 of 3 tuning:     mod_gbt (898ms) #> ‚Ñπ Model with lowest RMSE: mod_gbt #> ‚Ñπ Investigate trained learners and fitted model in `prognostic_info` list element #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  prog(ate) #> $formula #> Y ~ . #> <environment: 0x55a41b1c9a58> #>  #> $model_fit #> ‚ïê‚ïê Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Formula #> Model: boost_tree() #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Y ~ . #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ##### xgb.Booster #> raw: 28.3 Kb  #> call: #>   xgboost::xgb.train(params = list(eta = 0.1, max_depth = 3, gamma = 0,  #>     colsample_bytree = 1, colsample_bynode = 1, min_child_weight = 1,  #>     subsample = 1), data = x$data, nrounds = 25, watchlist = x$watchlist,  #>     verbose = 0, nthread = 1, objective = \"reg:squarederror\") #> params (as set within xgb.train): #>   eta = \"0.1\", max_depth = \"3\", gamma = \"0\", colsample_bytree = \"1\", colsample_bynode = \"1\", min_child_weight = \"1\", subsample = \"1\", nthread = \"1\", objective = \"reg:squarederror\", validate_parameters = \"TRUE\" #> xgb.attributes: #>   niter #> callbacks: #>   cb.evaluation.log() #> # of features: 1  #> niter: 25 #> nfeatures : 1  #> evaluation_log: #>   iter training_rmse #>  <num>         <num> #>      1     1.5862767 #>      2     1.4789534 #>    ---           --- #>     24     0.7886489 #>     25     0.7834327 #>  #> $learners #> $learners$mars #> $learners$mars$model #> MARS Model Specification (regression) #>  #> Main Arguments: #>   prod_degree = 3 #>  #> Computational engine: earth  #>  #>  #> $learners$mars$grid #> NULL #>  #>  #> $learners$lm #> $learners$lm$model #> Linear Regression Model Specification (regression) #>  #> Computational engine: lm  #>  #>  #> $learners$lm$grid #> NULL #>  #>  #> $learners$gbt #> $learners$gbt$model #> Boosted Tree Model Specification (regression) #>  #> Main Arguments: #>   trees = parsnip::tune(\"trees\") #>   tree_depth = parsnip::tune(\"tree_depth\") #>   learn_rate = 0.1 #>  #> Computational engine: xgboost  #>  #>  #> $learners$gbt$grid #>    trees tree_depth #> 1     25          3 #> 2     50          3 #> 3     75          3 #> 4    100          3 #> 5    125          3 #> 6    150          3 #> 7    175          3 #> 8    200          3 #> 9    225          3 #> 10   250          3 #> 11   275          3 #> 12   300          3 #> 13   325          3 #> 14   350          3 #> 15   375          3 #> 16   400          3 #> 17   425          3 #> 18   450          3 #> 19   475          3 #> 20   500          3 #>  #>  #>  #> $cv_folds #> [1] 5 #>  #> $data #>               Y          W1 #> 1    2.45324500  0.43214157 #> 2    1.74587608 -1.64330257 #> 3    3.00671022  1.76944998 #> 4    0.92501068  1.62584073 #> 5    1.14995932  0.85961475 #> 6    3.78330007  0.56236898 #> 7   -0.70898656 -0.09507107 #> 8    1.51371259 -1.89154224 #> 9   -0.59806292 -0.23782019 #> 10   0.95432740 -0.52714647 #> 11  -0.25802011  0.41978156 #> 12   1.72108165  1.37607739 #> 13   1.49089069  0.80556102 #> 14   1.08395060  0.58320252 #> 15   2.84515931 -0.87534534 #> 16   2.19033994  0.98487433 #> 17   0.58453527  1.30781885 #> 18   0.81905809  0.81692519 #> 19   0.51189106 -1.04007313 #> 20   0.66420194 -0.11545320 #> 21   0.76265786 -1.59566610 #> 22   2.24385690  0.93105532 #> 23   2.19391927  1.07320016 #> 24   1.83824052  1.82711705 #> 25   2.07003145 -0.65133166 #> 26   1.50321685 -0.88996702 #> 27   1.25360173 -0.40313316 #> 28   2.91663601 -1.04002381 #> 29   2.84533022 -0.57609965 #> 30   0.88919009 -0.75119442 #> 31   3.41656509  1.54931839 #> 32   3.58038372 -1.14571684 #> 33   1.26642453 -0.68788511 #> 34   0.80280585  0.64131460 #> 35   2.86001894  1.49031629 #> 36   0.93793877  0.68237403 #> 37   2.00143134  0.30220213 #> 38   2.67219454 -0.96858633 #> 39   2.59988462 -1.65636912 #> 40   2.21700892  1.37297887 #> 41   1.52226660 -1.61149583 #> 42   1.63718611 -0.16269570 #> 43   3.41661074 -1.93482001 #> 44   2.35564247  0.50384822 #> 45   0.74563036 -0.15328531 #> 46   0.34555996 -0.62027948 #> 47   2.89912685  1.02527397 #> 48   3.71882292 -1.68898323 #> 49   2.15758227 -0.72984326 #> 50   3.83930922 -1.27071160 #> 51   2.84106964  1.84424308 #> 52   2.71588587  1.18449416 #> 53   0.95295720  1.91443887 #> 54   1.69885432 -1.62046905 #> 55   2.39222497  0.66214264 #> 56   1.33498152  1.43002470 #> 57   1.86307419 -0.85786406 #> 58   1.74497471  0.19289431 #> 59   2.37629264 -1.19125243 #> 60   1.92885398  1.76962359 #> 61   2.74629354  0.61912167 #> 62   3.20969571  1.77492310 #> 63   2.31867213 -1.71932637 #> 64   1.73408423 -1.71210633 #> 65   0.61202909 -0.61496539 #> 66   1.42435423  1.34106230 #> 67   1.28028522 -0.20797865 #> 68   2.21743031  1.46991764 #> 69   2.90053443 -1.90889015 #> 70   3.29176308  1.98229927 #> 71   1.48190109 -1.36143251 #> 72   0.95214850 -1.84653080 #> 73   2.72879917  0.65119565 #> 74   3.37885262 -1.99758753 #> 75   2.20372345 -0.10024662 #> 76   1.62432440  0.48231955 #> 77   2.14352683 -0.12773523 #> 78   1.02571739 -0.27668677 #> 79   0.65946775 -0.05150794 #> 80   1.77403488  0.97827517 #> 81   0.61518368 -1.05569466 #> 82   0.07564095 -0.01409287 #> 83   2.14961952 -1.47163612 #> 84   2.27066939  0.65371288 #> 85   2.40451002 -1.12953596 #> 86   3.36633207  0.96862303 #> 87   1.91475498 -1.84884988 #> 88   2.33541681  0.60718878 #> 89   3.34011367 -0.66245731 #> 90   2.26722912 -1.11568765 #> 91   2.01757872 -1.91549550 #> 92   2.93237812  1.21704654 #> 93   1.57533720  1.98810874 #> 94   2.03212564 -0.55234637 #> 95   1.69931428  1.73978074 #> 96   2.48039170  0.63144518 #> 97   2.19019310  0.05422805 #> 98   0.48629511  0.29023363 #> 99   3.02494680  1.08236182 #> 100  2.00469718 -1.87888575 #>"},{"path":"https://nnpackages.github.io/postcard/reference/rctglm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"procedure uses plug--estimation influence functions perform robust inference specified estimand setting randomised clinical trial, even case heterogeneous effect covariates randomisation groups.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"","code":"rctglm(   formula,   exposure_indicator,   exposure_prob,   data,   family = gaussian,   estimand_fun = \"ate\",   estimand_fun_deriv0 = NULL,   estimand_fun_deriv1 = NULL,   cv_variance = FALSE,   cv_variance_folds = 10,   verbose = options::opt(\"verbose\"),   ... )"},{"path":"https://nnpackages.github.io/postcard/reference/rctglm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"formula object class \"formula\" (one can coerced class): symbolic description model fitted. details model specification given ‚ÄòDetails‚Äô glm documentation. exposure_indicator (name ) binary variable data identifies randomisation groups. variable required binary make \"orientation\" estimand_fun clear. exposure_prob numeric probabiliy \"group 1\" (rather group 0) groups defined exposure_indicator. default, ratio 1's data used. data optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found data, variables taken environment(formula), typically environment function called. family description error distribution link     function used model.  glm can     character string naming family function, family function     result call family function.  glm.fit     third option supported.  (See family details     family functions.) estimand_fun function arguments psi1 psi0 specifying estimand. Alternative, specify \"ate\" \"rate_ratio\" character use one default estimand functions. See details \"Estimand\" section documentation. estimand_fun_deriv0 function specifying derivative estimand_fun wrt. psi0. default algorithm use symbolic differentiation automatically find derivative estimand_fun estimand_fun_deriv1 function specifying derivative estimand_fun wrt. psi1. default algorithm use symbolic differentiation automatically find derivative estimand_fun cv_variance logical determining whether estimate variance using cross-validation (see details rctglm). cv_variance_folds numeric number folds use cross validation cv_variance TRUE. verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE') ... Additional arguments passed stats::glm()","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"rctglm returns object class inheriting \"rctglm\". object class rctglm list containing following components: estimand: data.frame plug-estimate estimand, standard error (SE) estimate variance estimate estimand estimand_funs: list f: estimand_fun used obtain estimate estimand counterfactual means d0: derivative respect psi0 d1: derivative respect psi1 means_counterfactual: data.frame counterfactual means psi0 psi1 fitted.values_counterfactual: data.frame counterfactual mean values, obtained transforming linear predictors group inverse link function. glm: glm object returned running stats::glm within procedure call: matched call See extract information using methods rctglm_methods.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"procedure assumes setup randomised clinical trial observations grouped binary exposure_indicator variable, allocated randomly probability exposure_prob. GLM fit used predict response observations event exposure_indicator 0 1, respectively. Taking means predictions produce counterfactual means psi0 psi1, estimand r(psi0, psi1) calculated using specified estimand_fun. variance estimand found taking variance influence function estimand. cv_variance TRUE, counterfactual predictions observation (used calculate value influence function) obtained --sample (OOS) predictions using cross validation number folds specified cv_variance_folds. cross validation splits performed using stratified sampling exposure_indicator strata argument rsample::vfold_cv. Read vignette(\"model-fit\").","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm.html","id":"estimands","dir":"Reference","previous_headings":"","what":"Estimands","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"noted description, psi0 psi1 counterfactual means found prediction using fitted GLM binary groups defined exposure_indicator. Default estimand functions can specified via \"ate\" (uses function function(psi1, psi0) psi1-psi0) \"rate_ratio\" (uses function function(psi1, psi0) psi1/psi0). See information specifying estimand_fun vignette(\"model-fit\"). default, Deriv package used perform symbolic differentiation find derivatives estimand_fun.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit GLM and find any estimand (marginal effect) using plug-in estimation with variance estimation using influence functions ‚Äî rctglm","text":"","code":"# Generate some data to showcase example n <- 100 exposure_prob <- .5  dat_gaus <- glm_data(   Y ~ 1+1.5*X1+2*A,   X1 = rnorm(n),   A = rbinom(n, 1, exposure_prob),   family = gaussian() )  # Fit the model ate <- rctglm(formula = Y ~ .,               exposure_indicator = A,               exposure_prob = exposure_prob,               data = dat_gaus,               family = gaussian) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  # Pull information on estimand estimand(ate) #>   Estimate Std. Error #> 1 1.973737  0.1906332  ## Another example with different family and specification of estimand_fun dat_binom <- glm_data(   Y ~ 1+1.5*X1+2*A,   X1 = rnorm(n),   A = rbinom(n, 1, exposure_prob),   family = binomial() )  rr <- rctglm(formula = Y ~ .,               exposure_indicator = A,               exposure_prob = exposure_prob,               data = dat_binom,               family = binomial(),               estimand_fun = \"rate_ratio\") #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1/psi0' with respect to 'psi0' as: '-(psi1/psi0^2)'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1/psi0' with respect to 'psi1' as: '1/psi0'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  odds_ratio <- function(psi1, psi0) (psi1*(1-psi0))/(psi0*(1-psi1)) or <- rctglm(formula = Y ~ .,               exposure_indicator = A,               exposure_prob = exposure_prob,               data = dat_binom,               family = binomial,               estimand_fun = odds_ratio) #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function '(psi1 * (1 - psi0))/(psi0 * (1 - psi1))' with respect to 'psi0' as: '{     .e1 <- 1 - psi1     .e2 <- psi0 * .e1     -(psi1 * ((1 - psi0) * .e1/.e2^2 + 1/.e2)) }'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function '(psi1 * (1 - psi0))/(psi0 * (1 - psi1))' with respect to 'psi1' as: '{     .e2 <- psi0 * (1 - psi1)     (1 - psi0) * (1/.e2 + psi0 * psi1/.e2^2) }'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`"},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for objects of class rctglm ‚Äî rctglm_methods","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"Methods mostly extract information model fit inference. See details information method.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"","code":"estimand(object)  # S3 method for class 'rctglm' estimand(object)  est(object)  # S3 method for class 'rctglm' coef(object, ...)  # S3 method for class 'rctglm' print(x, digits = max(3L, getOption(\"digits\") - 3L), ...)"},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"object object class rctglm ... additional arguments passed methods x object class rctglm digits numeric number digits display printing","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"function estimand (short-hand version est) can used extract data.frame estimated value standard error estimand. method generic coef added rctglm (.e., coef.rctglm), uses method coef.glm extract coefficient information underlying glm fit procedure.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for objects of class rctglm ‚Äî rctglm_methods","text":"","code":"# Generate some data to showcase example n <- 100 exposure_prob <- .5 dat_binom <- glm_data(   Y ~ 1+1.5*X1+2*A,   X1 = rnorm(n),   A = rbinom(n, 1, exposure_prob),   family = binomial() )  # Fit the model ate <- rctglm(formula = Y ~ .,               exposure_indicator = A,               exposure_prob = exposure_prob,               data = dat_binom,               family = binomial,               estimand_fun = \"ate\") #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  print(ate) #>  #> Object of class rctglm  #>  #> Call:  rctglm(formula = Y ~ ., exposure_indicator = A, exposure_prob = exposure_prob,  #>     data = dat_binom, family = binomial, estimand_fun = \"ate\") #>  #> Counterfactual control mean (psi_0=E[Y|X, A=0]) estimate: 0.6762 #> Counterfactual control mean (psi_1=E[Y|X, A=1]) estimate: 0.9097 #> Estimand function r: psi1 - psi0 #> Estimand (r(psi_1, psi_0)) estimate (SE): 0.2335 (0.076) estimand(ate) #>    Estimate Std. Error #> 1 0.2334771 0.07600023 coef(ate) #> (Intercept)          X1           A  #>   0.8528778   1.0275222   1.7464931"},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":null,"dir":"Reference","previous_headings":"","what":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"procedure uses fit_best_learner fit prognostic model historical data uses model produce counterfactual predictions prognostic score adjusted covariate rctglm procedure.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"","code":"rctglm_with_prognosticscore(   formula,   exposure_indicator,   exposure_prob,   data,   family = gaussian,   estimand_fun = \"ate\",   estimand_fun_deriv0 = NULL,   estimand_fun_deriv1 = NULL,   cv_variance = FALSE,   cv_variance_folds = 10,   ...,   data_hist,   prog_formula = NULL,   cv_prog_folds = 5,   learners = default_learners(),   verbose = options::opt(\"verbose\") )"},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"formula object class \"formula\" (one can coerced class): symbolic description model fitted. details model specification given ‚ÄòDetails‚Äô glm documentation. exposure_indicator (name ) binary variable data identifies randomisation groups. variable required binary make \"orientation\" estimand_fun clear. exposure_prob numeric probabiliy \"group 1\" (rather group 0) groups defined exposure_indicator. default, ratio 1's data used. data optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found data, variables taken environment(formula), typically environment function called. family description error distribution link     function used model.  glm can     character string naming family function, family function     result call family function.  glm.fit     third option supported.  (See family details     family functions.) estimand_fun function arguments psi1 psi0 specifying estimand. Alternative, specify \"ate\" \"rate_ratio\" character use one default estimand functions. See details \"Estimand\" section documentation. estimand_fun_deriv0 function specifying derivative estimand_fun wrt. psi0. default algorithm use symbolic differentiation automatically find derivative estimand_fun estimand_fun_deriv1 function specifying derivative estimand_fun wrt. psi1. default algorithm use symbolic differentiation automatically find derivative estimand_fun cv_variance logical determining whether estimate variance using cross-validation (see details rctglm). cv_variance_folds numeric number folds use cross validation cv_variance TRUE. ... Additional arguments passed stats::glm() data_hist data.frame historical data fit prognostic model prog_formula character numeric formula fitting prognostic model historical data data_hist. Default models response (assumed formula) using columns data_hist data cv_prog_folds numeric number cross-validation folds used fitting evaluating models learners list tidymodels verbose numeric verbosity level. Higher values means information printed console. value 0 means nothing printed console execution (Defaults 2, overwritable using option 'postcard.verbose' environment variable 'R_POSTCARD_VERBOSE')","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"rctglm_with_prognosticscore returns object class rctglm_prog, inherits rctglm. rctglm_prog object list components rctglm object (see Value section rctglm breakdown structure), additional list element : prognostic_info: List information fitted prognostic model historical data. components: formula: formula symbolic description response modelled function covariates models model_fit: trained workflow - result fit_best_learner learners: list learners used discrete super learner cv_folds: amount folds used cross validation data: historical data used cross validation fitting testing models","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"details prognostic models scores predictions counterfactual means control group.","code":""},{"path":"https://nnpackages.github.io/postcard/reference/rctglm_with_prognosticscore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use prognostic covariate adjustment when fitting an rctglm ‚Äî rctglm_with_prognosticscore","text":"","code":"# Generate some data n <- 100 b0 <- 1 b1 <- 1.5 b2 <- 2 W1 <- runif(n, min = -2, max = 2) exposure_prob <- .5  dat_treat <- glm_data(   Y ~ b0+b1*abs(sin(W1))+b2*A,   W1 = W1,   A = rbinom (n, 1, exposure_prob) )  dat_notreat <- glm_data(   Y ~ b0+b1*abs(sin(W1)),   W1 = W1 )  ate <- rctglm_with_prognosticscore(   formula = Y ~ .,   exposure_indicator = A,   exposure_prob = exposure_prob,   data = dat_treat,   family = gaussian(),   estimand_fun = \"ate\",   data_hist = dat_notreat) #>  #> ‚îÄ‚îÄ Fitting prognostic model ‚îÄ‚îÄ #>  #> ‚Ñπ Created formula for fitting prognostic model as: Y ~ . #> ‚Ñπ Fitting learners #> ‚Ä¢ mod_mars #> ‚Ä¢ mod_lm #> ‚Ä¢ mod_gbt #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 1 of 3 resampling: mod_mars #> ‚úî 1 of 3 resampling: mod_mars (121ms) #> i\tNo tuning parameters. `fit_resamples()` will be attempted #> i 2 of 3 resampling: mod_lm #> ‚úî 2 of 3 resampling: mod_lm (93ms) #> i 3 of 3 tuning:     mod_gbt #> ‚úî 3 of 3 tuning:     mod_gbt (909ms) #> ‚Ñπ Model with lowest RMSE: mod_gbt #> ‚Ñπ Investigate trained learners and fitted model in `prognostic_info` list element #>  #> ‚îÄ‚îÄ Symbolic differentiation of estimand function ‚îÄ‚îÄ #>  #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi0' as: '-1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv0` #> ‚Ñπ Symbolically deriving partial derivative of the function 'psi1 - psi0' with respect to 'psi1' as: '1'. #> ‚Ä¢ Alternatively, specify the derivative through the argument #> `estimand_fun_deriv1`  # Pull information on estimand estimand(ate) #>   Estimate Std. Error #> 1 2.195769   0.204792"},{"path":"https://nnpackages.github.io/postcard/news/index.html","id":"postcard-0219000-development-version","dir":"Changelog","previous_headings":"","what":"postcard 0.2.1.9000 (development version)","title":"postcard 0.2.1.9000 (development version)","text":"Major overhaul package. Still focuses analysing data use prognostic scores, takes general approach allows distribution response covariates within scope generalised linear models (GLMs) necessarily run number data sets created simulation. package provides novel methods : rctglm: Finding marginal effect estimand estimating standard error using influence functions avoid inflation type 1 error rctglm_with_prognosticscore: , leveraging historical data increase precision prognostic scores.","code":""},{"path":[]},{"path":"https://nnpackages.github.io/postcard/news/index.html","id":"features-0-2-1","dir":"Changelog","previous_headings":"","what":"Features","title":"postcard 0.2.1","text":"Added function simulate_collection takes function arguments simulate covariates model outcome historical ‚Äúcurrent‚Äù data give user full flexibility (previously multivariate normal distribution assumed) sim.lm simulates data multivariate normal distribution models outcome linear model now wrapper new - general - simulate_collection.","code":""},{"path":[]},{"path":"https://nnpackages.github.io/postcard/news/index.html","id":"features-0-2-0","dir":"Changelog","previous_headings":"","what":"Features","title":"postcard 0.2.0","text":"Added option use sandwich HC estimators covariance matrix sim.lm Updated default value ATE_shift sim.lm","code":""},{"path":"https://nnpackages.github.io/postcard/news/index.html","id":"code-cleanup-0-2-0","dir":"Changelog","previous_headings":"","what":"Code cleanup","title":"postcard 0.2.0","text":"Modularised code. Fx. split lm.hist lm.procova lm.psm Renamed functionalities Correcting errors documentation","code":""},{"path":"https://nnpackages.github.io/postcard/news/index.html","id":"best-practices-package-0-2-0","dir":"Changelog","previous_headings":"","what":"Best practices package","title":"postcard 0.2.0","text":"Updated DESCRIPTION Created README Added explicit package imports form foo::xx Added tests","code":""},{"path":"https://nnpackages.github.io/postcard/news/index.html","id":"postcard-010","dir":"Changelog","previous_headings":"","what":"postcard 0.1.0","title":"postcard 0.1.0","text":"Initial package created local files. Package contains functionalities create simulation study specific purpose related article. Functionalities include generation collection data sets way analyse data sets assuming special case multivariate normal distribution covariates linear model response. addition, functionalities estimate power certain parameter tests based results.","code":""}]
